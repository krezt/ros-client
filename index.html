<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Realm of Shinobi: Tournament of Legends - PvP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Server config: change to wss/ngrok later -->
  <script>window.PVP_WS_URL = "wss://ros-relay.onrender.com/ws";</script>

  <style>
    :root{
      --topbar-h: 60px;
      --actionbar-h: 216px;
      --safe-bottom: 50px;
      --gap: 10px;

      --bg: #0f0f13; --ink: #e8e8f0; --border: #3a4257;
      --panel: #161a24; --battle-bg: #14141b;

      --act-row-h: 76px;
      --act-gap: 8px;
      --act-pad-x: 12px;
      --act-pad-y: 8px;

      --btn-frame-url: none;
      --btn-slice: 12;
      --btn-bg: rgba(18,24,36,.9);
    }

    html,body{
      margin:0; padding:0; height:100%;
      background:var(--bg); color:var(--ink); font-family:monospace;
    }

    /* App grid */
    #app{
      height: calc(100vh - var(--safe-bottom));
      display: grid;
      grid-template-rows: var(--topbar-h) minmax(0, 1fr) var(--actionbar-h);
      grid-template-columns: minmax(640px, 2fr) minmax(360px, 1fr);
      gap: var(--gap);
      padding: var(--gap);
      box-sizing: border-box;
      overflow: hidden;
    }

    #battlefield, #log-wrap, #action-bar-left, #action-bar-right, #top-left, #top-right {
      min-width: 0; min-height: 0;
    }

    /* Top row */
    #top-left, #top-right{
      height: 100%;
      min-height: 0;
      display:flex; align-items:center; justify-content:center;
      background:#1b2231;
      border:2px solid var(--border);
      box-sizing: border-box;
    }
    #top-left { grid-column: 1; grid-row: 1; font-weight:700; font-size:24px; }
    #top-right{ grid-column: 2; grid-row: 1; }

    /* Battlefield (left middle) */
    #battlefield{
      grid-column:1; grid-row:2;
      min-width: 640px;
      min-height: 480px;
      width: 100%;
      height: 100%;
      border:2px solid var(--border);
      background:var(--battle-bg);
      box-sizing:border-box;
      overflow:hidden;
    }
    #battlefield canvas { display:block; max-width:none; max-height:none; image-rendering:pixelated; }

    /* Combat Log (right middle) */
    #log-wrap{
      grid-column: 2; grid-row: 2;
      border:2px solid var(--border);
      background:var(--panel);
      display:flex; flex-direction:column;
      min-width: 360px;
      height: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }
    #combat-log{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
      padding:10px 12px;
    }
    #combat-log h3{ margin:6px 0 10px 0; font-size:16px; color:#a7c4ff; }
    #combat-log .line{ font-size:15px; margin:2px 0; white-space:pre-wrap; }

    /* Bottom row */
    #action-bar-left, #action-bar-right{
      grid-row: 3;
      height: 100%;
      min-height: 0;
      overflow: hidden;
      border:2px solid var(--border);
      background:#1b2130;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: var(--act-pad-y) var(--act-pad-x) calc(var(--act-pad-y) + 4px);
      box-sizing: border-box;
    }
    #action-bar-left { grid-column: 1; }
    #action-bar-right{ grid-column: 2; }
#action-bar-right{
  background:#141a26; /* optional: darker frame behind the image */
}

#action-bar-right img{
  border-radius: 8px;
}


    /* Action bar inner shell */
    #action-bar-inner{
      width: 100%;
      display:flex; flex-direction:column; gap:8px;
      align-items:center;
      min-width: 0;
    }
    #action-prompt{
      font-weight: 800;
      font-size: 24px;
      text-align: center;
      line-height: 1.2;
      margin: 0;
    }

    /* Fixed 3√ó2 grid */
    #action-buttons{
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      grid-template-rows: repeat(2, var(--act-row-h));
      gap: var(--act-gap);
      width: 100%;
      min-width: 0;
      align-items: stretch;
      justify-items: stretch;
      overflow: hidden;
      max-width: 96%;
      margin-inline: auto;
    }
    #action-buttons .action-btn{ width:100%; min-width:0; height:100%; box-sizing:border-box; padding:8px 10px; }
    #action-buttons .action-btn img{ width:24px; height:24px; image-rendering: pixelated; flex:0 0 auto; }

    /* Button look */
    .action-btn{
      background:#22314b; color:#fff; border:1px solid #4a5a7a; border-radius:4px;
      display:flex; flex-direction:column; align-items:flex-start; white-space:normal; line-height:1.2; cursor:pointer;
      transition: transform .08s ease-out;
    }
    .action-btn:hover{ background:#2a3b5b; transform: translateY(-1px); }
    .action-btn:active{ transform: translateY(0); box-shadow: 0 1px 0 rgba(0,0,0,.35); }
    .action-btn .label{ font-weight:800; font-size:24px; }
    .action-btn .desc{
      font-size:14px; opacity:.9; margin-top:4px;
      display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden;
    }
    .action-btn.placeholder{ opacity: .35; border-style:dashed; cursor:default; }
    .action-btn.placeholder:hover{ transform:none; background:#22314b; }
    .action-btn.placeholder .label{ opacity:.8; }
    .action-btn.placeholder .desc{ display:none; }

    /* Nine-slice (optional) */
    .has-frame #action-buttons .action-btn{
      border: var(--btn-slice) solid transparent;
      border-image-source: var(--btn-frame-url);
      border-image-slice: var(--btn-slice) fill;
      border-image-width: var(--btn-slice);
      border-image-repeat: stretch;
      background: var(--btn-bg);
      border-radius:0;
    }

/* Speed dots on action buttons */
.action-btn .speed {
  position: absolute;
  top: 6px;
  right: 6px;
  display: flex;
  gap: 4px;
  pointer-events: none;
  opacity: .95;
}
.action-btn .speed .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  opacity: .75;
}
.action-btn .speed .off { opacity: .25; filter: grayscale(100%); }

/* colors for speed */
.action-btn .speed.fast  .dot      { background:#7cfc7c; }  /* green */
.action-btn .speed.normal .dot     { background:#ffd37a; }  /* yellow */
.action-btn .speed.slow  .dot      { background:#ff6b6b; }  /* red */
/* Put dots on the far right in normal flow (not absolute) */
.action-btn .btn-inner{
  display:flex;
  align-items:center;
  justify-content:space-between;
  width:100%;
}
.action-btn .speed.right{
  position: static;  /* override the absolute rule */
  top:auto; right:auto;
  margin-left:8px;
}

/* === Right-aligned speed dots (override any earlier rules) === */
.action-btn .btn-inner{
  display:flex;
  align-items:center;
  justify-content:space-between;
  width:100%;
  gap:8px;
}
.action-btn .btn-inner .text{
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  min-width:0;
  flex:1; /* <-- this pushes the dots all the way to the right */
}
/* FORCE the dots to live on the right, not absolute */
.action-btn .speed{
  position:static !important;
  top:auto !important;
  right:auto !important;
  margin-left:8px;
  flex:0 0 auto;
}
.action-btn .speed .dot{
  display:inline-block;
  width:8px; height:8px; border-radius:50%;
  margin-left:3px;
  opacity:.9;
}
.action-btn .speed .dot.off{ opacity:.35; filter:grayscale(1); }


    /* Error overlay */
    #error-overlay{position:fixed;inset:0;display:none;z-index:99999;overflow:auto;background:rgba(20,20,26,.92);color:#ffcccc;padding:16px;border:2px solid #663333}
    #error-overlay h1{margin-top:0;color:#ffd4d4}
    #error-overlay pre{white-space:pre-wrap}
  </style>

  <!-- Phaser -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
  <div id="error-overlay"><h1>‚ö†Ô∏è Prototype Error</h1><div id="err-msg"></div></div>

  <div id="app">
    <!-- top row -->
    <div id="top-left">Initializing‚Ä¶</div>
    <div id="top-right"></div>

    <!-- middle row -->
    <div id="battlefield"></div>
    <div id="log-wrap">
      <div id="combat-log"><h3>üìú Combat Log</h3></div>
    </div>

    <!-- bottom row -->
    <div id="action-bar-left"></div>
    <div id="action-bar-right"></div>
  </div>

  <!-- ===== BIG SCRIPT (open across all parts) ===== -->
  <script>
/* ---------- tiny DOM helper ---------- */
window.el = window.el || function el(tag, attrs = {}, ...kids){
  const n = document.createElement(tag);
  for (const [k, v] of Object.entries(attrs || {})) {
    if (k === 'class') n.className = v;
    else if (k === 'style' && v && typeof v === 'object') Object.assign(n.style, v);
    else n.setAttribute(k, v);
  }
  for (const kid of kids) {
    if (kid == null) continue;
    if (typeof kid === 'string') n.appendChild(document.createTextNode(kid));
    else n.appendChild(kid);
  }
  return n;
};

// ---------- limited-use reset (must exist before WS messages can trigger startBattleFromDraft) ----------
window.resetAbilityUsesForBattle = window.resetAbilityUsesForBattle || function resetAbilityUsesForBattle(units){
  for (const u of (units || [])) {
    if (!u) continue;
    // new system
    u._abilityUses = {};
    // clear legacy flags/counters (safe)
    delete u._godTempestUsed;
    delete u._shinobiPotionUses;
    delete u._rezUsed;
  }
};

/* ---------- error overlay ---------- */
(function(){
  function showErrorOverlay(m){
    var o=document.getElementById('error-overlay'), b=o.querySelector('#err-msg');
    b.innerHTML='<p><strong>Message:</strong></p><pre>'+ (m||'Unknown') +'</pre>'; o.style.display='block';
  }
  window.addEventListener('error',e=>{
    try{showErrorOverlay((e.message||'Error')+'\n'+(e.error&&e.error.stack?e.error.stack:''));}
    catch(_){showErrorOverlay(e.message||String(e));}
  });
})();

/* ---------- common DOM refs ---------- */
const topLeftEl     = document.getElementById('top-left');
const bfEl          = document.getElementById('battlefield');
const actionLeftEl  = document.getElementById('action-bar-left');
const actionRightEl = document.getElementById('action-bar-right');

/* ---------- log helpers ---------- */
function appendLog(line){
  const logEl = document.getElementById('combat-log'); if (!logEl) return;
  const div=document.createElement('div'); div.className='line'; div.textContent=line;
  logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight;
}
function appendLogHTML(html){
  const logEl = document.getElementById('combat-log'); if (!logEl) return;
  const div=document.createElement('div'); div.className='line'; div.innerHTML=html;
  logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight;
}
function logGreen(txt){ appendLogHTML(`<span style="color:#9be29b">${txt}</span>`); }
function logRed(txt){ appendLogHTML(`<span style="color:#ff6b6b">${txt}</span>`); }
function checkHPWarnings(u){
  if (!u) return;
  const p = u.hp / u.maxHP;
  u._hpWarn70 ||= false; u._hpWarn35 ||= false; u._hpWarn15 ||= false;
  if (!u._hpWarn70 && p > 0 && p <= 0.70){ logRed(`${u.name} is hurt!`); u._hpWarn70 = true; }
  if (!u._hpWarn35 && p > 0 && p <= 0.35){ logRed(`${u.name} is hurt badly!`); u._hpWarn35 = true; }
  if (!u._hpWarn15 && p > 0 && p <= 0.15){ logRed(`${u.name} is about to die!`); u._hpWarn15 = true; }
  if (p > 0.70){ u._hpWarn70 = u._hpWarn35 = u._hpWarn15 = false; }
  else if (p > 0.35){ u._hpWarn35 = u._hpWarn15 = false; }
  else if (p > 0.15){ u._hpWarn15 = false; }
}

/* ---------- action bar shell ---------- */
let actionInnerEl, actionPromptEl, actionButtonsEl;
function initActionBarShell(){
  if (!actionLeftEl) return;
  actionLeftEl.innerHTML = '';
  actionInnerEl     = document.createElement('div'); actionInnerEl.id  = 'action-bar-inner';
  actionPromptEl    = document.createElement('div'); actionPromptEl.id = 'action-prompt';
  actionButtonsEl   = document.createElement('div'); actionButtonsEl.id= 'action-buttons';
  actionInnerEl.appendChild(actionPromptEl); actionInnerEl.appendChild(actionButtonsEl);
  actionLeftEl.appendChild(actionInnerEl);
}

function setStaticRightPanelImage(url){
  const box = document.getElementById('action-bar-right');
  if (!box) { console.error('[RightPanel] #action-bar-right not found'); return; }

  // clear panel
  box.innerHTML = '';
  box.style.position = 'relative';

  // Create the <img> first (so you can see it even before load completes)
  const img = document.createElement('img');
  img.alt = '';
  img.draggable = false;
  img.style.width = '100%';
  img.style.height = '100%';
  img.style.objectFit = 'contain';
  img.style.imageRendering = 'pixelated';
  img.style.display = 'block';

  // If you are using raw.githubusercontent.com, this is usually safe:
  img.crossOrigin = 'anonymous';

  // Add it to the DOM right away
  box.appendChild(img);

  // Preload using the "old" pattern
  const pre = new Image();
  pre.crossOrigin = 'anonymous';

  pre.onload = () => {
    console.log('[RightPanel] loaded', url, pre.naturalWidth + 'x' + pre.naturalHeight);
    img.src = url; // set only after confirmed load
  };

  pre.onerror = (e) => {
    console.error('[RightPanel] FAILED', url, e);
    // Show a visible fallback so you know the box is working
    box.textContent = 'Right panel image failed to load.';
    box.style.color = '#ffb3b3';
    box.style.fontSize = '12px';
  };

  pre.src = (url || '').trim();

  // Debug: outline so you can confirm the panel has size
  box.style.outline = '2px solid rgba(255,0,0,.25)';
}

function clearActionBar(){ if (actionButtonsEl) actionButtonsEl.innerHTML = ''; if (actionPromptEl) actionPromptEl.textContent = ''; }

/* ---------- tiny async helpers ---------- */
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const SLEEP_TINY_MS=1500, END_TICK_DELAY_MS = 2000, ACTION_DELAY_MS=2000, ACTION_STEP_DELAY_MS=2000, ROUND_END_DELAY_MS=2000;

/* ---------- RNG (unified, deterministic) ---------- */
(function(){
  let _s = 1 >>> 0; // non-zero
  function _xr(){ _s^=(_s<<13)>>>0; _s^=_s>>>17; _s^=(_s<<5)>>>0; _s>>>=0; return (_s>>>0)/0x100000000; }
  window.__seedRNG = function(seed){ _s = (seed>>>0) || 1; };
  window.rand = function(){ return _xr(); };
  window.randInt = function(min,max){ return Math.floor(rand()*(max-min+1))+min; };
  window.chance = function(p){ return rand() < p; };
  window.seedRNG = window.__seedRNG; // friendly alias
})();

/* ---------- utils ---------- */
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const choice=(arr)=> arr[(rand()*arr.length)|0];

/* ---------- config ---------- */
const CONFIG = {
  BASE_HP: 55, HP_PER_TGH: 24,
  ATK_PER_STR: 1.5, SDM_PER_INT: 1.5,
  DEF_FROM_TGH: 0.75, DEF_FROM_QKN: 0.75,

  CC_BASE_MIN: 2, CC_BASE_MAX: 3, CC_SDM_PER_BONUS: 15, CC_MAX_CAP: 5,
  CRIT_BASE: 0.025, CRIT_CAP: 0.35, CRIT_QKN_FACTOR: 0.005, CRIT_INT_FACTOR: 0.005,
  DODGE_BASE: 0.025, DODGE_QKN_FACTOR: 0.0025, DODGE_CAP: 0.15,

  ARMOR_K: 0.025, DAMAGE_GLOBAL: 1.15,

  SHRUG_BASE: 0.05, SHRUG_TGH_FACTOR: 0.0025,

  BUFF_BASE_MIN: 3, BUFF_BASE_MAX: 4, BUFF_SDM_PER_BONUS: 15, BUFF_MAX_CAP: 6,

  PROC: {
    Cleric: { chance: 0.5 }, Mage: { chance: 0.5 }, Monk: { chance: 0.66 },
    Mystic: { chance: 0.5 }, Necromancer: { chance: 0.5 }, Paladin: { chance: 0.5 },
  },

  STACKS: { atk_up:{per:0.5,max:4}, sdm_up:{per:0.5,max:4}, def_up:{per:0.33,max:4}, def_down:{per:0.25,max:4} },

  MARKED_MULT: 1.85,
  ECHO_MULT: 1.20,
  SHIELDWALL_GUARD: 0.20,
  COUNTER_COEF: 0.30,
  STATCOEF_OVERRIDE: 1.0, // keep 1.0 to simplify tuning
  NO_GLOBAL_MULT: true,
  IGNORE_DEFPEN: false
};

window.STATUS_ICON_SIZE = 40;   // try 28, 32, 36

/* ---------- ability type overrides ---------- */
// ---------- Ability damage-type overrides (mag vs phys) ----------
// Safe init
window.ABILITY_TYPE_OVERRIDES = window.ABILITY_TYPE_OVERRIDES || Object.create(null);


// Helper: set many labels to a type at once
function __setType(type, labels){
  const O = window.ABILITY_TYPE_OVERRIDES;
  for (const name of labels) { if (name) O[name] = type; }
}

function safeVfxMs(ms){
  try { return (typeof vfxMs === 'function') ? vfxMs(ms) : ms; }
  catch { return ms; }
}
function safeVfxScale(px){
  try { return (typeof vfxScale === 'function') ? vfxScale(px) : px; }
  catch { return px; }
}

// Helper: set a label and its common variants (proc / dot / tick)
function __setWithVariants(type, label, {proc=true, dot=false, tick=false} = {}){
  const names = [label];
  if (proc) names.push(`${label} (proc)`);
  if (dot)  names.push(`${label} (dot)`);
  if (tick) names.push(`${label} (tick)`);
  __setType(type, names);
}

// ---- MAGIC damage sources (resist via SDM) ----
__setType('mag', [
  // Mage / Mystic / Cleric / Paladin holy/arcane/shadow/poison/elemental
  'Fireball', 'Ice Lance', 'Frost Nova', 'Lightning Bolt', 'Arcane Surge',
  'Arcane Blast', 'Meteor', 'Magic Missile', 'Smite', 'Piercing Light',
  'Holy Nova', 'Radiant Spear', 'Judgement', 'Thunderstrike',
  'Life Drain', 'Shadow Bolt', 'Bone Spear', 'Mind Spike', 'Psionic Lash',
  'Chi Burst', 'Warding Flare'
]);

// Explicit procs/ticks that are magical
__setType('mag', [
  'Lightning Bolt (proc)', 'Life Drip (proc)', 'Arcane Echo (proc)',
  'Burn (dot)', 'Burn (tick)', 'Poison (dot)', 'Rot (dot)', 'Curse (proc)'
]);

// Abilities that apply magical DoTs or repeat magic
__setWithVariants('mag', 'Arcane Echo', {proc:true});
__setWithVariants('mag', 'Poison',     {proc:true, dot:true, tick:true}); // DoT ticks count as mag in this model
__setWithVariants('mag', 'Burn',       {proc:false, dot:true, tick:true});
__setWithVariants('mag', 'Rot',        {proc:false, dot:true, tick:true});
__setWithVariants('mag', 'Life Drip',  {proc:true}); // necro lifesteal proc
__setWithVariants('mag', 'Lightning Bolt', {proc:true});

// Paladin holy splash in your logs (treated as magic)
__setWithVariants('mag', 'Sanctify', {proc:false});

// Cleric beam in your logs (treated as magic)
__setWithVariants('mag', 'Piercing Light', {proc:false});

// Mage surge in your logs (treated as magic)
__setWithVariants('mag', 'Arcane Surge', {proc:true});

// ---- PHYSICAL damage sources (resist via DEF) ----
__setType('phys', [
  // Weapon / martial / arrows / bashes
  'Shield Bash', 'Shield Slam', 'Slash', 'Cleave', 'Whirlwind', 'Charge',
  'Crushing Blow', 'Uppercut', 'Palm Hit', 'Stun Kick', 'Flurry',
  'Snipe', 'Multi Shot', 'Volley', 'Piercing Arrow', 'Trap',
  'Backstab', 'Eviscerate', 'Poison Dagger', 'Execute', 'Frenzy', 'Smash', 'Leap'
]);

// Physical DoTs/Procs
__setType('phys', [
  'Bleed (dot)', 'Bleed (tick)', 'Counter (proc)'
]);

// Make sure these key labels from your logs are covered explicitly:
__setWithVariants('phys', 'Palm Hit');
__setWithVariants('phys', 'Snipe');
__setWithVariants('mag',  'Piercing Light');       // (already set above, but safe)
__setWithVariants('mag',  'Sanctify');             // (already set above, but safe)
__setWithVariants('phys', 'Poison Dagger');        // base hit is phys; its poison DoT is mag (set separately above)
__setWithVariants('mag',  'Hunter\'s Mark', {proc:false}); // mark is non-damage but leave as mag if any proc reads it
__setWithVariants('mag',  'Premonition',   {proc:false});  // status only; type won‚Äôt be used

// If you have unique names not in this list, add them here:
// window.ABILITY_TYPE_OVERRIDES['Your Ability'] = 'mag'; // or 'phys'

// ---------- END overrides ----------

/* ---------- jobs & stats ---------- */
const ALL_CLASSES = ['Shinobi','Warrior','Barbarian','Electromancer','Rogue','Cleric','Mage','Paladin','Archer','Monk','Necromancer','Mystic'];
const JOBS = {
  Warrior:  { STR:26,QKN:16,INT:8, TGH:36, kind:'phys', name:'Warrior' },
  Shinobi:  { STR:24,QKN:24,INT:10, TGH:26, kind:'phys', name:'Shinobi' },
  Electromancer: { STR:10,QKN:15,INT:32, TGH:25, kind:'mag', name:'Electromancer' },
  Rogue:    { STR:22,QKN:30,INT:8,TGH:27,  kind:'phys', name:'Rogue' },
  Cleric:   { STR:7, QKN:18,INT:28,TGH:29, kind:'mag',  name:'Cleric' },
  Barbarian:{ STR:33,QKN:12, INT:7,TGH:34, kind:'phys', name:'Barbarian' },
  Mage:     { STR:8, QKN:14,INT:35,TGH:27, kind:'mag',  name:'Mage' },
  Paladin:  { STR:24,QKN:12,INT:16,TGH:30, kind:'phys', name:'Paladin' },
  Archer:   { STR:22,QKN:25,INT:8, TGH:25, kind:'phys', name:'Archer' },
  Monk:     { STR:24,QKN:28,INT:8, TGH:25, kind:'phys', name:'Monk' },
  Necromancer:{STR:7,QKN:14, INT:34,TGH:27, kind:'mag',  name:'Necromancer' },
  Mystic:   { STR:8, QKN:27,INT:31,TGH:24, kind:'mag',  name:'Mystic' }
};
function deriveStats(job){
  const HP  = CONFIG.BASE_HP + job.TGH*CONFIG.HP_PER_TGH;
  const ATK = job.STR*CONFIG.ATK_PER_STR;
  const SDM = job.INT*CONFIG.SDM_PER_INT;
  const DEF = job.TGH*CONFIG.DEF_FROM_TGH + job.QKN*CONFIG.DEF_FROM_QKN;
  const CRIT = CONFIG.CRIT_BASE + (CONFIG.CRIT_BONUS?.[job.name]||0);
  return { HP:Math.round(HP), ATK, SDM, DEF, CRIT };
}
function makeUnit(jobName, team){
  const job = JOBS[jobName], d = deriveStats(job);
  const u = new Unit(jobName, team, jobName);
  u.maxHP = d.HP; u.hp = d.HP;
  u.ATK = d.ATK; u.SDM = d.SDM; u.DEF = d.DEF; u.CRIT = d.CRIT;
  u.QKN = job.QKN;                
  return u;
}

class Unit{
  constructor(name, team, jobName){
    const job = JOBS[jobName], d = deriveStats(job);
    this.name = name || jobName;
    this.team = team;
    this.job  = jobName;
    this.kind = job.kind;
    this.maxHP = d.HP; this.hp = d.HP;
    this.ATK = d.ATK; this.SDM = d.SDM; this.DEF = d.DEF;
    this.CRIT = d.CRIT;
    this.QKN = job.QKN; 
    this.status = [];
    this._ui = null;
  }
  alive(){ return this.hp>0; }
}

// One-line blurbs for draft UI
window.CLASS_BLURBS = {
  Shinobi: "Utility fighter, lethal combo abilities and attacks.",
  Warrior: "Frontline protector with taunt and team shielding.",
  Barbarian: "High damage bruiser who breaks defenses and snowballs on kills.",
  Electromancer: "Explosive caster with dangerous and volatile lightning magic.",
  Rogue: "Fast skirmisher with poison, blinds, and burst crits.",
  Cleric: "Team healer with buffs and a single resurrection.",
  Mage: "Explosive caster with stuns and heavy AoE.",
  Paladin: "Sturdy support with stuns, cleanse, and a clutch shield.",
  Archer: "Ranged pressure with marks, volleys, and big snipes.",
  Monk: "Combo striker with multi-hits, counters, and utility cleanses.",
  Necromancer: "Poison engine with drains and plague detonations.",
  Mystic: "Control mage with stuns, berserk, and speed manipulation."
};

function applyHeal(caster, target, healSpecOrAbility, {
  label = 'Heal',
  showVFX = true,
  curePoison = false
} = {}){
  if (!target) return 0;

  const H = computeAbilityHeal(caster, target, healSpecOrAbility);
  const before = target.hp;

  target.hp = clamp(target.hp + H, 0, target.maxHP);

  // If we revived them elsewhere and they were at 0, your alive() may depend on hp>0.
  // This function does NOT auto-revive; it only heals.

  const healed = target.hp - before;

  if (curePoison) removeStatusKey(target, 'poison');

  target._refresh && target._refresh();
  if (typeof checkHPWarnings === 'function') checkHPWarnings(target);

  if (showVFX && healed > 0){
    try {
      // green pop + green tint
      vfxFlashColor?.(target, { color: 0xa7ffb5, ms: 450, alpha: 0.16 });
      vfxFloatText?.(target, `+${healed}`, {
  color: (VFX_COL?.heal || '#57ff7a'),
  ms: (VFX?.FLOAT_MS ?? 1500),
  fontSize: 22
});

    } catch {}
  }

  return healed;
}

function applyHealFlat(target, amount, { showVFX=true } = {}){
  if (!target || amount<=0) return 0;
  const before = target.hp;
  target.hp = clamp(target.hp + amount, 0, target.maxHP);
  const healed = target.hp - before;
  target._refresh && target._refresh();
  checkHPWarnings?.(target);

  if (showVFX && healed > 0){
  vfxHealImpact(null, target, healed, 'Heal');
}

  return healed;
}

function applyHealAmount(caster, target, amount, { abilityName='Heal', showVFX=true } = {}){
  if (!target || amount <= 0) return { healed: 0 };

  const before = target.hp;
  target.hp = clamp(target.hp + amount, 0, target.maxHP);
  const healed = target.hp - before;

  target._refresh && target._refresh();
  if (typeof checkHPWarnings === 'function') checkHPWarnings(target);

  if (showVFX && healed > 0){
    vfxHealImpact?.(caster, target, healed, abilityName);
  }

  return { healed };
}

/* ---------- abilities (now with min/max healing where relevant) ---------- */
function abilitiesFor(u){
  switch(u.job){
   
/* ===== Electromancer ===== */
case 'Electromancer': return [

  /* 1) Attack (fast) ‚Äî small chance to stun (dur 1) */
  {
    label: 'Attack',
    desc: 'Electric shock. Small chance to stun 2 rounds with physical attack.',
    speed: 'fast', type: 'phys', target: 'enemy',
    base: { min: 18, max: 28 }, statCoef: 0.45, isBasic: true,

    stunChance: 0.15,

    use: function(a, t){
      if (!t || !t.alive()) return;

      vfxActCue?.(a, this.label);
      hit(a, t, { ability: this });

      if (t.alive() && chance(this.stunChance)){
        pushStatus(t, { key:'stun', dur: 2 });
        appendLogHTML?.(`<span style="color:${VFX_COL?.cc || '#b084ff'}">‚ö° ${t.name} is stunned!</span>`);
      }
    }
  },

  /* 2) Electrical Storm (fast) ‚Äî AoE chip + AoE heal + small chance to stun enemies (dur 1) */
  {
  label: 'Electrical Storm',
  desc: 'Zap enemies and energize allies. Small chance to disorient enemies.',
  speed: 'fast', type: 'mag', target: 'all-enemies',

  base: { min: 4, max: 6 }, statCoef: 0.25,
  heal: { min: 4, max: 6 }, healCoef: 0.18, scalesWith: 'SDM',

  stunChance: 0.15,

  use: function(a, foes){
    const allies  = (a.team === 'player') ? player : enemy;
    const enemies = Array.isArray(foes) ? foes.filter(u => u && u.alive()) : [];
    const friends = allies.filter(u => u && u.alive());

    vfxActCue?.(a, this.label);

    // Cosmetic: caster -> all enemies (staggered)
    try {
      vfxCastToTargets?.(a, enemies, {
        label: this.label,
        proj: { ms: (VFX?.PROJ_MS ?? 750) * 0.80, color: 0xa7c4ff, radius: 6 },
        onImpact: (t) => vfxFlashColor?.(t, { color: 0xa7c4ff, ms: vfxMs(320), alpha: 0.22 }),
        staggerMs: (VFX?.AOE_STAGGER_MS ?? 120)
      });
    } catch {}

    // Damage + stun roll per enemy (suppress hit() travel/cue to avoid double VFX)
    for (const t of enemies){
      hit(a, t, { ability: this, noActCueVFX:true, noProjectileVFX:true });
      if (t.alive() && chance(this.stunChance)) pushStatus(t, { key:'stun', dur: 1 });
    }

    // Heal allies (use unified helper)
    for (const ally of friends){
      const H = computeAbilityHeal(a, ally, this);
      if (H > 0) applyHealAmount(a, ally, H, { abilityName: this.label, showVFX: true });
    }

    appendLogHTML?.(`<span style="color:#a7c4ff">‚ö° ${a.name} unleashes an Electrical Storm.</span>`);
  }
},

  /* 3) Chain Lightning (normal) ‚Äî massive hit, 50% bounce, no repeats
     - projectile travels FROM last target TO next target (chain feel)
     - no hard cap needed: no-repeats implicitly caps to living unit count
  */
  {
  label: 'Chain Lightning',
  desc: 'Massive damage. 65% chance to jump to a new random target (any team), repeating.',
  speed: 'normal', type: 'mag', target: 'enemy',
  base: { min: 85, max: 125 }, statCoef: 0.65,
  bounceChance: 0.65,

  use: async function(a, first){
    if (!first || !first.alive()) return;

    // One cue up front
    vfxActCue?.(a, this.label);

    const all = [...player, ...enemy]
      .filter(u => u && u.alive())
      .sort((x,y) => String(x.netId ?? x.name).localeCompare(String(y.netId ?? y.name)));

    const seen = new Set();
    const idOf = (u) => String(u.netId ?? u.name);

    let cur = first;
    let prev = a;

    // how long the hop projectile takes (match hit() mag projectile feel)
    const hopMs = Math.floor((VFX?.PROJ_MS ?? 400) * 1.15);
    const hopPause = Math.max(40, Math.floor(hopMs * 0.55)); // readability pause

    while (cur && cur.alive()){
      const id = idOf(cur);
      if (seen.has(id)) break;
      seen.add(id);

      // IMPORTANT: let hit() draw the projectile from prev -> cur
      hit(a, cur, {
        ability: this,
        vfxFrom: prev,
        noActCueVFX: true,      // we already cued once above
        // noProjectileVFX: false // default; leave it
      });

      // give time for the hop to visually ‚Äúlaunch‚Äù before we select next hop
      if (typeof sleep === 'function') await sleep(hopPause);

      if (rand() >= this.bounceChance) break;

      const pool = all.filter(u => u.alive() && !seen.has(idOf(u)));
      if (!pool.length) break;

      prev = cur;
      cur = pool[(rand() * pool.length) | 0];
    }

    appendLogHTML?.(`<span style="color:#a7c4ff">‚ö° ${a.name}'s Chain Lightning crackles through the field!</span>`);
  }
},


  /* 4) God Tempest (normal) ‚Äî self-only, once per game:
     - remove ALL negative effects
     - restore to full HP
     - gain SDM‚Üë and DEF‚Üë
  */
  {
    label: 'God Tempest',
    desc: 'Once per game: cleanse negatives, restore to full HP, gain SDM‚Üë and DEF‚Üë.',
    speed: 'normal', type: 'mag', target: 'self',
    usesMax: 1,
    usesKey: 'god_tempest',
    usesSpendInUse: true,
    sdmDur: 4,
    defDur: 4,

    use: function(a){
      if (!a) return;
      // Backward compatible: if old flag exists, mirror it
if (a._godTempestUsed) {
  appendLog(`${a.name} has already used God Tempest.`);
  return;
}

// Spend the one use here (single source of truth)
if ((this.usesMax|0) > 0 && !spendUse(a, this)) {
  appendLog(`${a.name} has already used God Tempest.`);
  return;
}


      // ---- CLEANSE ALL NEGATIVES ----
      // Your engine doesn't tag statuses with "kind", so we need an explicit list.
      // Add/remove keys here as your game grows.
      const NEGATIVE_KEYS = new Set([
        'stun','taunt','blind','berserk',
        'def_down','poison','bleed',
        'marked'
        // add more negative keys here as needed
      ]);

      const beforeN = (a.status || []).length;
a.status = (a.status || []).filter(s => !NEGATIVE_KEYS.has(s.key));
const removed = beforeN - a.status.length;

      // Full heal
      const beforeHP = a.hp;
      a.hp = a.maxHP;
      syncDeathState?.(a);

      a._refresh && a._refresh();
      checkHPWarnings?.(a);
      updateStatusView?.(a);

      // Buffs (stackable by your engine; fine)
      pushStatus(a, { key:'sdm_up', dur: this.sdmDur });
      pushStatus(a, { key:'def_up', dur: this.defDur });

      // VFX
      vfxActCue?.(a, this.label);
      vfxFlashColor?.(a, { color: 0xa7c4ff, ms: vfxMs(450), alpha: 0.22 });
      vfxFloatText?.(a, `TEMPEST`, { ms: vfxMs(1500), fontSize: Math.floor(vfxScale(16)), color: '#a7c4ff' });

      const healed = Math.max(0, a.hp - beforeHP);
      if (healed > 0) vfxHealImpact?.(a, a, healed, this.label);

      appendLogHTML?.(`<span style="color:#a7c4ff">üå©Ô∏è ${a.name} invokes God Tempest ‚Äî cleansed ${removed} effects and restored to full health!</span>`);
    }
  },

  /* 5) Shift (normal) ‚Äî dodge ALL physical attacks for 3 rounds
     Requires: tryDodge() patch => if hasStatus(defender,'shift') return true;
  */
  {
    label: 'Shift',
    desc: 'On cast and one additional round, dodge all physical type attacks.',
    speed: 'normal', type: 'mag', target: 'self',

    use: function(a){
      const dur = 2;
      removeStatusKey(a, 'shift');
      pushStatus(a, { key:'shift', dur });

      vfxActCue?.(a, this.label);
      vfxFlashColor?.(a, { color: 0xbdbdff, ms: vfxMs(360), alpha: 0.18 });
      vfxFloatText?.(a, `SHIFT ${dur}`, { ms: vfxMs(1500), fontSize: Math.floor(vfxScale(14)), color: '#bdbdff' });

      appendLogHTML?.(`<span style="color:#bdbdff">‚ú® ${a.name} shifts out of phase (Shift ${dur}).</span>`);
    }
  },

  /* 6) Power Surge (slow) ‚Äî AoE ally ATK buff (STACKS) */
  {
  label: 'Power Surge',
  desc: 'Empower all allies with ATK‚Üë (stacks).',
  speed: 'slow', type: 'mag', target: 'all-allies',
  dur: 3,

  use: function(a, allies){
    const list = Array.isArray(allies) ? allies.filter(u => u && u.alive()) : [];
    const dur = this.dur;

    vfxActCue?.(a, this.label);

    for (const t of list){
      pushStatus(t, { key:'atk_up', dur }); // <-- status VFX handled by pushStatus now
      // keep a tiny non-status cosmetic if you want, but DON'T show ATK‚Üë text again:
      vfxFlashColor?.(t, { color: 0xa7c4ff, ms: vfxMs(260), alpha: 0.14 });
    }

    appendLogHTML?.(`<span style="color:#a7c4ff">‚ö° ${a.name} surges power through the team (ATK‚Üë ${dur}).</span>`);
  }
},


];

/* ===== Shinobi ===== */
case 'Shinobi': return [

  /* 1) Attack (fast) ‚Äî chance to proc double strike
     - If shinobi_haste: +1 guaranteed extra swing
     - Each swing has its own proc roll (max 4 hits)
  */
  {
    label: 'Attack',
    desc: 'Fast strike. Chance to double strike.',
    speed: 'fast', type: 'phys', target: 'enemy',
    base: { min: 30, max: 55 }, statCoef: 0.45, isBasic: true,

    procChance: 0.55,

    use: function(a, t){
  if (!t || !t.alive?.()) return;

  const hasteOn = hasStatus(a, 'shinobi_haste');
  const swings = 1 + (hasteOn ? 1 : 0);

  vfxActCue?.(a, this.label);
  vfxProjectile?.(a, t, { ms: 220, color: 0xc9c9ff, radius: 4 });

  let hits = 0;
  let procHits = 0;

  const scene = getScene?.();
  const hitGap = (typeof vfxMs === 'function') ? vfxMs(110) : 110; // tiny spacing between hit VFX

  // Pre-roll proc outcomes deterministically (still uses your rand/chance in order)
  const plan = [];
  for (let i = 0; i < swings; i++){
    plan.push({ kind: 'base' });
    // proc check happens after base hit, same as your logic
    plan.push({ kind: 'proc', do: chance(this.procChance) });
  }

  // Execute immediately for mechanics, but schedule "impact feel" callouts
  // IMPORTANT: hit() should already be doing the actual damage+numbers.
  // We're only spacing out the FEEL and combo tag.
  let stepIndex = 0;

  for (let i = 0; i < swings; i++){
    if (!t.alive?.()) break;

    hit(a, t, { ability: this });
    hits++;
    stepIndex++;

    if (t.alive?.() && chance(this.procChance)){
      hit(a, t, { ability: this });
      hits++;
      procHits++;
      stepIndex++;
    }
  }

  // Combo callouts once per action (at the end, slightly delayed so it reads well)
  const doComboPop = () => {
    if (!t.alive?.()) return;

    if (hits === 3){
      vfxFloatText?.(t, `3 HIT COMBO!`, { ms: vfxMs?.(1100) ?? 1100, fontSize: 20, color: '#c9c9ff' });
      vfxFlashColor?.(t, { color: 0xc9c9ff, ms: vfxMs?.(220) ?? 220, alpha: 0.18 });
    } else if (hits >= 4){
      vfxFloatText?.(t, `4 HIT SUPER COMBO!`, { ms: vfxMs?.(1250) ?? 1250, fontSize: 24, color: '#ffd37a' });
      vfxFlashColor?.(t, { color: 0xffd37a, ms: vfxMs?.(240) ?? 240, alpha: 0.18 });
    } else if (procHits > 0){
      // still show a smaller proc-only tag if you want
      vfxFloatText?.(t, `COMBO!`, { ms: vfxMs?.(1000) ?? 1000, fontSize: 15, color: '#c9c9ff' });
    }

  };

  const comboDelay = Math.max(0, (hits - 1)) * hitGap;
  if (scene?.time?.delayedCall) scene.time.delayedCall(comboDelay, doComboPop);
  else doComboPop();
}

  },

  /* 2) Thief‚Äôs Haste (slow) ‚Äî refreshable */
  {
    label:"Thief's Haste",
    desc:'Gain an additional basic attack for the next 3 rounds.',
    speed:'slow', type:'mag', target:'self',
    use:function(a){
      const dur = 4;
      removeStatusKey(a,'shinobi_haste');
      pushStatus(a,{key:'shinobi_haste', dur});

      vfxActCue?.(a, this.label);
      vfxFlashColor?.(a, { color: 0xc9c9ff, ms: vfxMs(300), alpha: 0.18 });
      vfxFloatText?.(a, `HASTE ${dur}`, { ms: vfxMs(1500), fontSize: Math.floor(vfxScale(14)), color: '#c9c9ff' });

      appendLogHTML?.(`<span style="color:#c9c9ff">ü•∑ ${a.name} uses Thief's Haste (${dur}).</span>`);
    }
  },

  /* 3) Invisibility (normal) ‚Äî untargetable for 2 rounds */
  {
    label: 'Invisibility',
    desc: 'Become untargetable from cast and next round.',
    speed: 'slow', type: 'mag', target: 'self',
    use: function(a){
      const dur = 2;
      removeStatusKey(a, 'invisible');
      pushStatus(a, { key:'invisible', dur });

      vfxActCue?.(a, this.label);
      vfxFlashColor?.(a, { color: 0xbdbdff, ms: vfxMs(360), alpha: 0.16 });
      vfxFloatText?.(a, `INVISIBLE ${dur}`, { ms: vfxMs(1500), fontSize: Math.floor(vfxScale(14)), color: '#bdbdff' });

      appendLogHTML?.(`<span style="color:#bdbdff">ü•∑ ${a.name} vanishes (Invisibility ${dur}).</span>`);
    }
  },

  /* 4) Bleed (medium) ‚Äî apply status; tick handled by endRoundTick patch */
  {
    label: 'Bleed',
    desc: 'Strike and inflict Bleed: 15% current HP at end of round for 4 rounds.',
    speed: 'medium', type: 'phys', target: 'enemy',
    base: { min: 22, max: 36 }, statCoef: 0.45,
    pct: 0.15,

    use: function(a, t){
  if (!t || !t.alive()) return;

  vfxActCue?.(a, this.label);

  const r = hit(a, t, { ability: this }); // <-- capture
  if (!t.alive()) return;

  // If dodged OR dealt no damage, do NOT apply bleed
  if (r?.dodged || (r?.dealt|0) <= 0) return;

  const dur = 4;
  removeStatusKey(t, 'bleed');
  pushStatus(t, { key:'bleed', dur, data:{ pct:this.pct ?? 0.15, src:a?.name } });

  appendLogHTML?.(`<span style="color:#ff7a7a">ü©∏ ${t.name} is bleeding (${dur}).</span>`);
}

  },

  /* 5) Potion of Regeneration (fast) ‚Äî 3 uses; heal 30-40%; cure poison */
  {
    label: 'Regen Potion',
    desc: 'Heal 25‚Äì35% max HP and cure poison.',
    speed: 'fast', type: 'mag', target: 'self',
    usesMax: 3,
    usesKey: 'potion_regen',
    usesSpendInUse: true,
    pctMin: 0.30,
    pctMax: 0.40,

    use: function(a){
      if (!a) return;

     
if ((this.usesMax|0) > 0 && !spendUse(a, this)) {
  appendLog(`${a.name} has no Potions of Regeneration left.`);
  return;
}

      removeStatusKey(a, 'poison');

      const pct = this.pctMin + (rand() * (this.pctMax - this.pctMin));
      const H = Math.max(1, Math.floor(a.maxHP * pct));

      const before = a.hp;
      a.hp = clamp(a.hp + H, 0, a.maxHP);
      const healed = a.hp - before;

      a._refresh && a._refresh();
      checkHPWarnings?.(a);

      vfxActCue?.(a, this.label);
      vfxFlashColor?.(a, { color: 0x57ff7a, ms: vfxMs(320), alpha: 0.22 });
      if (healed > 0) vfxHealImpact?.(a, a, healed, this.label);
      vfxFloatText?.(a, `POTION (${getUsesLeft(a, this)} left)`, {
  ms: vfxMs(1200), fontSize: 13, color: (VFX_COL?.buff || '#a7c4ff')
});


      appendLogHTML?.(`<span style="color:#9dffb3">üß™ ${a.name} drinks a potion and heals ${healed}.</span>`);
    }
  },

{
  label: 'Dispel',
  desc: 'Remove all effects except poison/bleed from any target.',
  speed: 'fast', type: 'mag', target: 'any',

  use: function(a, t){
    // ALWAYS prove it fired
    console.log('[Dispel] USE FIRED', a?.name, '->', t?.name);

    if (!t){
      appendLog?.(`${a?.name || 'Someone'} tries to Dispel, but no target was passed.`);
      return;
    }

    const keep = new Set(['poison','bleed']);

    const before = Array.isArray(t.status) ? t.status.slice() : [];
    const beforeKeys = before.map(s => s?.key).filter(Boolean);

    // Remove everything except poison/bleed
    const after = before.filter(s => keep.has(s.key));
    t.status = after;

    const removedKeys = beforeKeys.filter(k => !keep.has(k));

    // Refresh UI safely
    try { updateStatusView?.(t); } catch (e) { console.warn('updateStatusView failed', e); }
    try { t._refresh?.(); } catch (e) { console.warn('_refresh failed', e); }

    // VFX (don‚Äôt rely on hit())
    try {
      vfxActCue?.(a, 'Dispel');
      vfxProjectile?.(a, t, { ms: 320, color: 0xa7c4ff, radius: 5 });

      const scene = getScene?.();
      const impactDelay = Math.max(0, Math.floor(((typeof vfxMs==='function'? vfxMs(320):320)) * 0.90));
      const doImpact = () => {
        vfxFlashColor?.(t, { color: 0xa7c4ff, ms: (typeof vfxMs==='function'? vfxMs(280):280), alpha: 0.20 });
        vfxFloatText?.(t, `DISPEL`, {
          ms: (typeof vfxMs==='function'? vfxMs(1100):1100),
          fontSize: Math.floor((typeof vfxScale==='function'? vfxScale(14):14)),
          color: '#a7c4ff'
        });
      };
      if (scene?.time?.delayedCall) scene.time.delayedCall(impactDelay, doImpact);
      else doImpact();
    } catch (e) {
      console.warn('Dispel VFX failed', e);
    }

    // Combat log ALWAYS
    if (removedKeys.length){
      appendLogHTML?.(`<span style="color:#a7c4ff">‚ú® ${a.name} dispels ${t.name}: removed <b>${removedKeys.join(', ')}</b>.</span>`)
      || appendLog?.(`${a.name} dispels ${t.name}: removed ${removedKeys.join(', ')}.`);
    } else {
      appendLogHTML?.(`<span style="color:#a7c4ff">‚ú® ${a.name} dispels ${t.name}, but nothing happens.</span>`)
      || appendLog?.(`${a.name} dispels ${t.name}, but nothing happens.`);
    }
  }
},


];


    /* ===== Warrior ===== */
case 'Warrior': return [
  {label:'Attack', desc:'Good old sword and board.', speed:'normal', type:'phys', target:'enemy',
   base:{min:65,max:75}, statCoef:0.35, isBasic:true,
   use:function(a,t){ return hit(a,t,{ability:this}); } },

{
  label:'Warhorn',
  desc:'Heal and briefly bolster yourself with strength and ability quickness.',
  speed:'slow', type:'mag', target:'self',

  use:function(a){
    const atkDur = 3;
    pushStatus(a, { key:'atk_up', dur: atkDur });

    const preDur = 2;
    pushStatus(a, { key:'premonition', dur: preDur });

    const healSpec = { heal:{ min:15, max:25 }, healCoef:0.18, scalesWith:'ATK', type:'mag' };
    const H = computeAbilityHeal(a, a, healSpec);

    const before = a.hp;
    a.hp = clamp(a.hp + H, 0, a.maxHP);
    const healed = a.hp - before;

    a._refresh && a._refresh();
    checkHPWarnings?.(a);

    // Keep ONE overhead cue for the action
    vfxActCue?.(a, 'Warhorn');

    // Heal VFX slightly after (still fine)
    const scene = getScene();
    const delay = vfxMs(VFX?.STATUS_TO_HEAL_MS ?? 90);
    if (healed > 0){
      const doHealVFX = () => vfxHealImpact?.(a, a, healed, 'Warhorn');
      if (scene?.time?.delayedCall) scene.time.delayedCall(delay, doHealVFX);
      else doHealVFX();
    }

    appendLog(`${a.name} sounds the Warhorn and surges with strength and quickness. ${a.name} heals ${healed}.`);
  }
},


  {label:'Power Strike', desc:'Slow, potentially heavy blow.', speed:'slow', type:'phys', target:'enemy',
   base:{min:80,max:140}, statCoef:0.60,
   use:function(a,t){ return hit(a,t,{ability:this}); } },

  {label:'Insult', desc:'Taunt an enemy into attacking you.', speed:'normal', type:'phys', target:'enemy',
 use:(a,t)=>{
   if(!t.alive()) return appendLog(`${a.name}'s Taunt has no effect on the dead.`);
   if(rand()<0.60){
     const dur=ccDurBySDM(a);
     applyHardCC(a, t, 'taunt', dur, { data:{ taunter:a }});

     appendLogHTML(`<span style="color:#b084ff">${a.name} taunts ${t.name}! ${t.name} must attack ${a.name} for ${dur} round(s).</span>`);
   } else {
     appendLog(`${a.name}'s insults fail to have any effect whatsoever.`);
   }
 }},

  {label:'Shieldwall', desc:'Allies gain mitigation; intercept first hit.', speed:'fast', type:'phys', target:'all-allies',
   use:(a,arr)=>{
     for (const ally of arr){
       pushStatus(ally, { key:'guard', dur:1, data:{ pct:(CONFIG.SHIELDWALL_GUARD||0.20) }});
     }
     pushStatus(a, { key:'shield_redirect', dur:1, data:{ remaining:1 }});
     appendLogHTML(`${a.name} raises <b>Shieldwall</b> to protect the team!`);
   }}
];


    /* ===== Barbarian ===== */
    case 'Barbarian': return [
      {label:'Attack', desc:'A consistently strong basic attack.', speed:'normal', type:'phys', target:'enemy',
       base:{min:70,max:90}, statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Rend', desc:'Expose your target‚Äôs weakness.', speed:'slow', type:'phys', target:'enemy',
       base:{min:70,max:120}, statCoef:0.35,
       use:function(a,t){ const r=hit(a,t,{ability:this});
         if(t.alive()){ const dur=buffDurBySDM(a); pushStatus(t,{key:'def_down', dur}); appendLog(`${t.name}‚Äôs defense is lowered (${dur}).`);} return r; } },

      {label:'War Cry', desc:'Damage all enemies and lower their defense.', speed:'normal', type:'mag', target:'all-enemies',
       base:{min:10,max:25}, statCoef:0.25,
       use:function(a,arr){ for(const t of arr){ if(!t.alive()) continue; hit(a,t,{ability:this}); }
         const dur=buffDurBySDM(a); for(const t of arr){ if(!t.alive()) continue; pushStatus(t,{key:'def_down', dur}); }
         appendLog(`All enemies‚Äô defense is reduced (${dur}).`); } },

     {label:'Smash', desc:'Crushing blow with chance to stun.', speed:'slow', type:'phys', target:'enemy',
 base:{min:70,max:115}, statCoef:0.55,
 use:function(a,t){
   const r=hit(a,t,{ability:this});
   if(t.alive() && rand()<0.25){
     const dur=ccDurBySDM(a);
     applyStatusWithLog(t,'stun',dur,'#b084ff',`${t.name} is stunned for {dur} rounds!`, a);
   }
   return r;
 }},

      {label:'Rampage', desc:'Swing that grants rampage on killshot.', speed:'normal', type:'phys', target:'enemy',
       base:{min:75,max:110}, statCoef:0.45,
       use:function(a,t){
         const hpBefore = t.hp;
         const r = hit(a,t,{ability:this});
         if (hpBefore>0 && t.hp<=0){
           const dur = (buffDurBySDM(a)+1);
           pushStatus(a,{key:'atk_up', dur});
           appendLogHTML(`<span style="color:#ff927a">${a.name} goes on a Rampage! ATK‚Üë (${dur}).</span>`);
         }
         return r;
       }}
    ];

    /* ===== Rogue ===== */
    case 'Rogue': return [
      {label:'Backstab', desc:'Go for the vitals.', speed:'slow', type:'phys', target:'enemy',
       base:{min:60,max:100}, statCoef:0.40, critBonus:0.95,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Attack', desc:'Hard slice at your enemy.', speed:'fast', type:'phys', target:'enemy',
       base:{min:35,max:70}, statCoef:0.45, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Poison Dagger', desc:'Cover your blade with poison for this attack.', speed:'normal', type:'phys', target:'enemy',
       base:{min:30,max:55}, statCoef:0.30,
       use:function(a,t){
         const r = hit(a,t,{ability:this});
         if (t.alive() && r.dealt > 0){
           addPoison(t, r.dealt);
           logGreen(`${t.name} is hit with a poisoned dagger (+${r.dealt}).`);
         }
         return r;
       }},

      {label:'Shadowstep', desc:'Strike quickly and defend.', speed:'fast', type:'phys', target:'enemy',
       base:{min:35,max:45}, statCoef:0.30,
       use:function(a,t){
         const r = hit(a,t,{ability:this});
         const dur = buffDurBySDM(a);
         pushStatus(a,{key:'def_up', dur});
         appendLog(`${a.name} slips back and contemplates their next move (${dur}).`);
         return r;
       }},

        {
       label:'Smoke Bomb',
       desc:'Blind all enemies this round and heal for 15% of max HP.',
       speed:'fast', type:'mag', target:'all-enemies',

       use:function(a, arr){
         const targets = (arr || []).filter(t => t?.alive?.());
         const scene = getScene?.();

         // --- MECHANICS: apply blind dur=1 (unchanged) ---
         let n = 0;
         for (const t of targets){
           pushStatus(t, { key:'blind', dur:1 });
           n++;
         }

         // --- VFX ONLY: caster -> each target, then BLIND tag after arrival ---
         try {
           const extraTagDelay = vfxMs?.(80) ?? 80;

           vfxCastToTargets?.(a, targets, {
             label: 'Smoke Bomb',
             proj: { ms: (VFX?.PROJ_MS ?? 750) * 0.85, color: (VFX?.CC_HEX ?? 0xb084ff), radius: 7 },
             onImpact: (t) => {
               const doTag = () => vfxHardCC?.(a, t, 'blind', { ms: 800, showOrigin: false });
               if (scene?.time?.delayedCall) scene.time.delayedCall(extraTagDelay, doTag);
               else doTag();
             },
             staggerMs: (VFX?.AOE_STAGGER_MS ?? 150)
           });
         } catch {}

         // --- MECHANICS: self-heal 15% max HP (unchanged) ---
         const healAmt = Math.max(1, Math.floor(a.maxHP * 0.15));
         const out = applyHealAmount(a, a, healAmt, { abilityName: 'Smoke Bomb' });

         appendLogHTML(`${a.name} throws <b>Smoke Bomb</b>! ${n} foe(s) are blinded. ${a.name} recovers ${out.healed} HP.`);
       }
     },

    ];


    /* ===== Cleric ===== */
case 'Cleric': return [
{
  label: 'Defensive Aura',
  desc: 'Quickly heal an ally and bolster their defense.',
  speed: 'fast', type: 'mag', target: 'ally',
  heal: { min: 25, max: 45 }, healCoef: 0.25, scalesWith: 'SDM',

  use: function(a, t){
    if (!t) return;

    const dur = buffDurBySDM(a);
    pushStatus(t, { key: 'def_up', dur }); // status VFX handled by pushStatus

    const H = computeAbilityHeal(a, t, this);
    const out = applyHealAmount(a, t, H, { abilityName: 'Defensive Aura', showVFX: false });

    vfxActCue?.(a, 'Defensive Aura');

    const scene = getScene();
    const delay = vfxMs(VFX?.STATUS_TO_HEAL_MS ?? 90);
    if (out.healed > 0){
      if (scene?.time?.delayedCall) scene.time.delayedCall(delay, () => vfxHealImpact?.(a, t, out.healed, 'Defensive Aura'));
      else vfxHealImpact?.(a, t, out.healed, 'Defensive Aura');
    }

    appendLog(`${a.name} blesses ${t.name} with Defensive Aura: DEF‚Üë (${dur}), healed for ${out.healed}.`);
  }
},

  {
    label: 'Attack',
    desc: 'Basic strike with a holy mace.',
    speed: 'normal', type: 'phys', target: 'enemy',
    base: { min: 10, max: 20 }, statCoef: 0.75, isBasic: true,
    use: function(a, t){ return hit(a, t, { ability: this }); }
  },

{
  label: `Enid's Blessing`,
  desc: 'Heal all allies and cure poison.',
  speed: 'slow', type: 'mag', target: 'all-allies',
  heal: { min: 25, max: 55 }, healCoef: 0.40, scalesWith: 'SDM',
  use: function(a, arr){
    let healedTotal = 0;
    let curedCount  = 0;

    const allies = (arr || []).filter(u => u?.alive?.());
    const scene = getScene();

    // Timing aligned with your AoE VFX helper (COSMETIC ONLY)
    const projMs = vfxMs(((VFX?.PROJ_MS ?? 750) * 1.10));
    const impactDelay = Math.max(0, Math.floor(projMs * 0.90));
    const step = vfxMs(VFX?.AOE_STAGGER_MS ?? 140);

    // --- VFX ONLY: who cast + caster->each ally motion ---
    try {
      vfxCastToTargets?.(a, allies, {
        label: ``,
        proj: { ms: (VFX?.PROJ_MS ?? 750) * 1.10, color: 0x57ff7a, radius: 7 },
        onImpact: (t) => {
          vfxFlashColor?.(t, { color: 0xa7ffb5, ms: 360, alpha: 0.20 });
        },
        staggerMs: (VFX?.AOE_STAGGER_MS ?? 140)
      });
    } catch {}

    // --- ORIGINAL MECHANICS (unchanged) ---
    for (const ally of (arr || [])){
      if (!ally?.alive?.()) continue;

      const H = computeAbilityHeal(a, ally, this);

      const before = ally.hp;
      ally.hp = clamp(ally.hp + H, 0, ally.maxHP);
      const healed = ally.hp - before;
      healedTotal += healed;

      const wasPoisoned = hasStatus(ally, 'poison');
if (wasPoisoned){
  removeStatusKey(ally, 'poison');
  curedCount++;
}

      ally._refresh && ally._refresh();
      checkHPWarnings(ally);

      // --- COSMETIC ONLY: guaranteed visible heal feedback ---
      if (healed > 0){
        vfxFlashColor?.(ally, { color: 0xa7ffb5, ms: 450, alpha: 0.18 });
        vfxFloatText?.(ally, `+${healed}`, {
  ms: vfxMs(VFX?.FLOAT_MS ?? 1250),
  fontSize: 22,
  color: (VFX_COL?.heal || '#57ff7a') // optional: explicit green, though your vfxFloatText now defaults +numbers to heal green
});
      }

      // --- COSMETIC ONLY: impact-timed extras (CURED tag) ---
      try {
        const i = allies.indexOf(ally);
        if (scene?.time?.delayedCall && i >= 0){
          const when = (i * step) + impactDelay;
          const amt = healed;
          const cured = wasPoisoned;

          scene.time.delayedCall(when, () => {
            if (cured){
              vfxFloatText?.(ally, `CURED`, {
                ms: vfxMs(900),
                fontSize: Math.floor(vfxScale(14))
              });
              vfxFlashColor?.(ally, { color: 0x57ff7a, ms: 240, alpha: 0.18 });
            }
          });
        }
      } catch {}

      appendLog(`${a.name} channels Enid‚Äôs Blessing: ${ally.name} healed for ${healed}${wasPoisoned ? ' and cured of poison' : ''}.`);
    }

    // (You can use healedTotal/curedCount later if you want a summary log)
  }
},


  {
    label: 'Piercing Light',
    desc: 'Holy bolt that pierces defense.',
    speed: 'slow', type: 'mag', target: 'enemy',
    base: { min: 45, max: 80 }, statCoef: 0.55, defPen: 0.25,
    use: function(a, t){ return hit(a, t, { ability: this }); }
  },

{
  label: 'Resurrection',
  desc: 'Revive a fallen ally (once) or heal if alive.',
  speed: 'slow', type: 'mag', target: 'ally',
  usesMax: 1,
usesKey: 'resurrection',
usesConsumesOn: 'revive', // only spend the ‚Äúcharge‚Äù when reviving a dead ally
usesSpendInUse: true,
allowDeadTarget: true,

  // Optional: keep heal numbers on the ability so you can reuse `this`
  heal: { min: 20, max: 40 }, healCoef: 0.30, scalesWith: 'SDM',

  use: function(a, t){
    if (!t) return;

    // One-time revive gate
    if (!t.alive?.()) {
  // revive attempt consumes the limited use
  if ((this.usesMax|0) > 0 && !spendUse(a, this)) {
  appendLog(`${a.name} has already used Resurrection.`);
  return;
}

}

    // If alive: treat as a normal heal using THIS ability's heal stats
    if (t.alive?.()){
      const H = computeAbilityHeal(a, t, this);
      const before = t.hp;

      t.hp = clamp(t.hp + H, 0, t.maxHP);
      const healed = t.hp - before;

      t._refresh && t._refresh();
      checkHPWarnings(t);

      // VFX (if you've got these helpers)
      vfxActCue?.(a, this.label);
      vfxHeal?.(t, healed);           // if you added it
      vfxFloatText?.(t, `+${healed}`, { ms: (VFX?.FLOAT_MS ?? 1500), fontSize: 22 });

      appendLog(`${a.name} invokes Resurrection on ${t.name} ‚Äî healed for ${healed}.`);
      return;
    }

    // If dead: revive with % HP, cure poison, reset KO latches
    const reviveHP = Math.max(1, Math.floor(t.maxHP * 0.45));
    t.hp = reviveHP;

// Spend the one-time revive charge NOW (only when a revive actually happens)
if ((this.usesMax|0) > 0) spendUse(a, this);

// Keep legacy flag for safety
a._rezUsed = true;

    // Clear poison + any ‚Äúdead state‚Äù flags so KO can happen again later
    removeStatusKey(t, 'poison');
    t._didKOVFX   = false;
    t._deadLogged = false;

    t._refresh && t._refresh();
    checkHPWarnings(t);

    // VFX (optional)
    vfxActCue?.(a, this.label);
    if (typeof vfxResurrect === 'function') vfxResurrect(t);
    vfxFlashColor?.(t, { color: 0xa7c4ff, ms: 650, alpha: 0.25 });
    vfxFloatText?.(t, `REVIVE ${reviveHP}`, { ms: 1500, fontSize: 22 });

    appendLogHTML(`<span style="color:#a7c4ff">‚úù ${a.name} resurrects ${t.name} with ${reviveHP} HP!</span>`);

  }
},

];


    /* ===== Mage ===== */
    case 'Mage': return [
      {label:'Arcane Surge', desc:'Increase your defense and casting power.', speed:'fast', type:'mag', target:'self',
       use:(a)=>{ const dur=buffDurBySDM(a); pushStatus(a,{key:'def_up', dur}); pushStatus(a,{key:'sdm_up', dur});
         appendLog(`${a.name} is warded from harm and flows with powerful magic (${dur}).`);} },

      {label:'Attack', desc:'Basic attack with lightning dagger.', speed:'normal', type:'phys', target:'enemy',
       base:{min:15,max:30}, statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

     {label:'Meteor', desc:'Fast meteor strike with chance to stun.', speed:'fast', type:'mag', target:'enemy',
 base:{min:25,max:55}, statCoef:0.45,
 use:function(a,t){
   const r=hit(a,t,{ability:this});
   if(t.alive() && rand()<0.25){
     const dur=ccDurBySDM(a);
     applyStatusWithLog(t,'stun',dur,'#b084ff',`${t.name} is hit with a meteor and dazed for {dur} rounds!`, a);
   }
   return r;
 }},

      {label:'Fireball', desc:'Large fireball that scorches all foes.', speed:'slow', type:'mag', target:'all-enemies',
       base:{min:50,max:90}, statCoef:0.50, defPen:0.20,
       use:function(a,arr){ for(const t of arr){ if(!t.alive()) continue; hit(a,t,{ability:this}); } } },

      {label:'Arcane Echo', desc:'Your spells cast twice next turn.', speed:'normal', type:'mag', target:'self',
       use:(a)=>{ pushStatus(a,{key:'arcane_echo', dur:2}); appendLog(`${a.name} prepares a devastating Arcane Echo.`); }}
    ];

    /* ===== Paladin ===== */
    case 'Paladin': return [
      {label:'Attack', desc:'Basic sword & board attack.', speed:'normal', type:'phys', target:'enemy',
       base:{min:50,max:55}, statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Shield Bash', desc:'Quick bash with a small chance to stun.', speed:'fast', type:'phys', target:'enemy',
 base:{min:25,max:45}, statCoef:0.35,
 use:function(a,t){
   const r=hit(a,t,{ability:this});
   if(t.alive() && rand()<0.3){
     const dur=ccDurBySDM(a);
     applyStatusWithLog(t,'stun',dur,'#b084ff',`${t.name} is smacked with the Crusader Shield and stunned for {dur} rounds!`, a);
   }
   return r;
 }},

    {
  label:'Cleanse',
  desc:'Remove ailments and heal small wounds.',
  speed:'normal', type:'mag', target:'ally',
  heal:{min:15,max:25}, healCoef:0.50, scalesWith:'SDM',

  use:function(a,t){
    if (!t) return;

    const removed = cleanseCCAndDebuffs(t);

    // heal using this ability's numbers
    const H = computeAbilityHeal(a, t, this);
    const out = applyHealAmount(a, t, H, { abilityName: 'Cleanse', showVFX: false });

    // (keep your KO latch clearing behavior exactly)
    if (t.hp > 0){
      t._didKOVFX = false;
      t._deadLogged = false;
    }

    // VFX: cleanse pop first, then heal pop slightly after (cosmetic only)
    vfxActCue?.(a, 'Cleanse');

    if (removed){
      vfxStatus?.(t, 'cleanse', { kind:'buff' });
      vfxFlashColor?.(t, { color: 0xa7c4ff, ms: vfxMs(500), alpha: 0.20 });
      vfxFloatText?.(t, 'CLEANSE', { ms: vfxMs(1100), fontSize: Math.floor(vfxScale(18)), color: (VFX_COL?.buff || '#a7c4ff') });
    }

    const scene = getScene();
    const delay = vfxMs((VFX?.STATUS_TO_HEAL_MS ?? 90) + (removed ? 90 : 0)); // tiny extra gap if cleanse fired
    if (out.healed > 0){
      if (scene?.time?.delayedCall) scene.time.delayedCall(delay, () => vfxHealImpact?.(a, t, out.healed, 'Cleanse'));
      else vfxHealImpact?.(a, t, out.healed, 'Cleanse');
    }

    const removedText = removed ? ' ailments removed,' : '';
    appendLog(`${a.name} casts Cleanse on ${t.name}:${removedText} healed for ${out.healed}.`);
  }
},


      {label:'Sanctify', desc:'Smite all enemies.', speed:'slow', type:'mag', target:'all-enemies',
       base:{min:20,max:60}, statCoef:0.40,
       use:function(a,arr){ for(const t of arr){ if(!t.alive()) continue; hit(a,t,{ability:this}); } } },

      {label:'Divine Shield', desc:'One ally takes no damage this round.', speed:'fast', type:'mag', target:'ally',
       use:(a,t)=>{ pushStatus(t,{key:'divine_shield', dur:1}); appendLog(`${a.name} acts heroically, ${t.name} is protected by Divine Shield.`); }}
    ];

    /* ===== Archer ===== */
    case 'Archer': return [
     {
  label:`Ranger's Focus`,
  desc:'Heal an ally and boost their attack.',
  speed:'normal', type:'mag', target:'ally',
  heal:{min:25,max:35}, healCoef:0.25, scalesWith:'ATK',

  use:function(a,t){
    if (!t) return;

    const dur = buffDurBySDM(a);
    pushStatus(t,{ key:'atk_up', dur }); // status VFX handled by pushStatus

    const H = computeAbilityHeal(a, t, this);
    const out = applyHealAmount(a, t, H, { abilityName: `Ranger's Focus`, showVFX: false });

    if (t.hp > 0){
      t._didKOVFX = false;
      t._deadLogged = false;
    }

    vfxActCue?.(a, `Ranger's Focus`);

    const scene = getScene();
    const delay = vfxMs(VFX?.STATUS_TO_HEAL_MS ?? 90);
    if (out.healed > 0){
      if (scene?.time?.delayedCall) scene.time.delayedCall(delay, () => vfxHealImpact?.(a, t, out.healed, `Ranger's Focus`));
      else vfxHealImpact?.(a, t, out.healed, `Ranger's Focus`);
    }

    appendLog(`${a.name} focuses ${t.name}: ATK‚Üë (${dur}), healed for ${out.healed}.`);
  }
},

      {label:'Attack', desc:'Loose a quick arrow.', speed:'fast', type:'phys', target:'enemy',
       base:{min:45,max:60}, statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Volley', desc:'Rain arrows over the battlefield.', speed:'normal', type:'phys', target:'all-enemies',
       base:{min:5,max:100}, statCoef:0.30,
       use:function(a,arr){ for(const t of arr){ if(!t.alive()) continue; hit(a,t,{ability:this}); } } },

      {label:'Snipe', desc:'Take careful aim for the vitals.', speed:'slow', type:'phys', target:'enemy',
       base:{min:60,max:135}, statCoef:0.65, critBonus:0.30,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:`Hunter's Mark`, desc:'Target takes increased damage until end of next round.', speed:'normal', type:'phys', target:'enemy',
       use:(a,t)=>{ if(!t.alive()) return appendLog(`${t.name} is already down.`);
         pushStatus(t,{key:'marked', dur:2});
         appendLogHTML(`${a.name} targets ${t.name} with <b>Hunter's Mark</b>. <span style="color:#ffd37a">${t.name} is now very susceptible to damage!</span>`);
       }}
    ];

    /* ===== Monk ===== */
    case 'Monk': return [
      {label:'Flurry', desc:'Three successive strikes.', speed:'slow', type:'phys', target:'enemy',
       base:{min:50,max:65}, statCoef:0.35,
       use:function(a,t){ for(let i=1;i<=3;i++){ if(!t.alive()) break;
         a._usingAbilityLabel = `Flurry (${i}/3)`; hit(a,t,{ability:this}); a._usingAbilityLabel = undefined; } } },

      {label:'Attack', desc:'Strike with increasing confidence.', speed:'fast', type:'phys', target:'enemy',
       base:{min:45,max:55}, statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Chi Wave', desc:'Cleanse CC/debuffs from all allies.', speed:'normal', type:'mag', target:'all-allies',
       use:(a,arr)=>{ let count=0; for(const ally of arr){ if(!ally.alive()) continue;
         if(cleanseCCAndDebuffs(ally)) count++; updateStatusView(ally); }
         appendLog(count ? `A Chi Wave rips accross the battlefield. Negative effects washed away from ${count} allies.` : `No negative effects to cleanse.`); } },

      {label:'Palm Hit', desc:'Body blow that may stagger foes.', speed:'normal', type:'phys', target:'enemy',
 base:{min:40,max:50}, statCoef:0.4,
 use:function(a,t){
   const r=hit(a,t,{ability:this});
   if(t.alive() && rand()<0.33){
     const dur=ccDurBySDM(a);
     applyStatusWithLog(t,'stun',dur,'#b084ff',`${t.name} is staggered for {dur} rounds!`, a);
   }
   return r;
 }},

      {label:'Counterstance', desc:'Guard and counter basic attacks.', speed:'fast', type:'phys', target:'self',
       use:(a)=>{ pushStatus(a,{key:'guard', dur:1, data:{ pct:0.40 }}); pushStatus(a,{key:'counter', dur:1}); appendLog(`${a.name} adopts a counter stance.`); }}
    ];

    /* ===== Necromancer ===== */
    case 'Necromancer': return [
      {label:'Attack', desc:'Basic attack with chance to drain.', speed:'normal', type:'phys', target:'enemy',
       base:{min:10,max:20}, statCoef:0.40, isBasic:true,
       use:function(a,t){
        const r = hit(a,t,{ability:this});
        return r;
       }},

      {
  label:'Life Drain',
  desc:'Steal life from a foe.',
  speed:'normal', type:'mag', target:'enemy',
  base:{min:30,max:60}, statCoef:0.35,

  use:function(a,t){
    if (!a || !t) return;

    // Compute (same as hit() path, but this is a self-contained drain)
    const res = computeAbilityDamage(a, t, this);

    // If dodged: show travel + dodge on target (clarity)
    if (res.dodged){
      const abType = res._type || getAbilityType(a, this);
      const projMs = (abType === 'mag') ? Math.floor((VFX?.PROJ_MS ?? 260) * 1.15) : (VFX?.PROJ_MS ?? 260);

      vfxActCue?.(a, this.label);
      vfxProjectile?.(a, t, { ms: projMs, color: 0xa7c4ff, radius: 6 });

      const scene = getScene?.();
      const impactDelay = Math.max(0, Math.floor(projMs * 0.75));
      const doDodge = () => vfxDodge?.(t);

      if (scene?.time?.delayedCall) scene.time.delayedCall(impactDelay, doDodge);
      else doDodge();

      appendLogHTML(`${t.name} <span style="color:skyblue">dodges</span> ${a.name}‚Äôs Life Drain!`);
      return;
    }

    if (!res.hit || (res.dmg|0) <= 0){
      vfxActCue?.(a, this.label);
      vfxFloatText?.(t, 'RESIST', { ms: 900, fontSize: 14 });
      appendLog(`${a.name}'s Life Drain fails to take hold.`);
      return;
    }

    const dealt = Math.max(1, res.dmg|0);

    // Apply drain
    const tBefore = t.hp;
    const aBefore = a.hp;

    t.hp = clamp(t.hp - dealt, 0, t.maxHP);
    a.hp = clamp(a.hp + dealt, 0, a.maxHP);

    // Clear KO latches if healed above 0 (edge cases)
    if (a.hp > 0){ a._didKOVFX = false; a._deadLogged = false; }

    t._refresh?.(); a._refresh?.();
    checkHPWarnings?.(t); checkHPWarnings?.(a);

    // VFX sequence: attacker cue ‚Üí travel ‚Üí impact ‚Üí heal pop
    const projMs = Math.floor((VFX?.PROJ_MS ?? 260) * 1.15);
    const scene = getScene?.();
    const impactDelay = Math.max(0, Math.floor(projMs * 0.90));

    vfxActCue?.(a, this.label);
    vfxProjectile?.(a, t, { ms: projMs, color: 0xa7c4ff, radius: 6 });

    const finalT = t;
    const finalA = a;
    const crit   = !!res.crit;

    const doImpact = () => {
      // Target takes damage (use your unified helpers if present)
      if (typeof vfxDamage === 'function') vfxDamage(finalT, dealt, { crit, kind:'drain' });
      else {
        vfxFlashColor?.(finalT, { color: 0xa7c4ff, ms: 450, alpha: 0.18 });
        vfxShakePanel?.(finalT, { px: (VFX?.SHAKE_PX ?? 6), ms: (VFX?.SHAKE_MS ?? 220) });
        vfxFlashPanel?.(finalT, { ms: (VFX?.FLASH_MS ?? 180) });
        vfxFloatText?.(finalT, `-${dealt}`, { ms: (VFX?.FLOAT_MS ?? 900), fontSize: crit ? 28 : 20 });
      }

      // Attacker gets healed
      vfxHeal?.(finalA, dealt);
      vfxFlashColor?.(finalA, { color: 0xa7ffb5, ms: 450, alpha: 0.16 });
      vfxFloatText?.(finalA, `+${Math.max(0, finalA.hp - aBefore)}`, { ms: (VFX?.FLOAT_MS ?? 900), fontSize: 18 });

      // KO announcement + KO VFX if drain killed them
      if (tBefore > 0 && finalT.hp <= 0){
        appendLogHTML(`<span style="color:#ff6b6b">‚ò† ${finalT.name} is down!</span>`);
        if (!finalT._didKOVFX){
          finalT._didKOVFX = true;
          vfxKO?.(finalT);
        }
        finalT._refresh?.();
      } else {
        finalT._didKOVFX = false;
      }
    };

    if (scene?.time?.delayedCall) scene.time.delayedCall(impactDelay, doImpact);
    else doImpact();

    // Log
    if (res.crit){
      appendLogHTML(`${a.name}‚Äôs Life Drain lands a <span style="color:gold">critical</span> siphon! ${t.name} loses ${dealt}. ${a.name} is healed for ${Math.max(0, a.hp - aBefore)}.`);
    } else {
      appendLog(`Life Drain siphons ${dealt} from ${t.name}. ${a.name} is healed for ${Math.max(0, a.hp - aBefore)}.`);
    }
  }
},


{
  label:'Plague',
  desc:'Afflict all foes with massive poison.',
  speed:'slow', type:'mag', target:'all-enemies',
  base:{min:20,max:65}, statCoef:0.30,

  use:function(a, arr){
    console.log('[Plague] use fired (version A)', a?.name, 'targets=', (arr||[]).length);
    const aliveTargets = (arr || []).filter(t => t?.alive?.());
    if (!aliveTargets.length){
      appendLog?.(`${a.name} casts Plague, but there are no targets.`);
      return;
    }

    // --- timing helpers (don‚Äôt require safeVfxMs/safeVfxScale) ---
    const ms   = (x)=> (typeof vfxMs==='function' ? vfxMs(x) : (x|0));
    const sc   = (x)=> (typeof vfxScale==='function' ? vfxScale(x) : x);
    const scene = getScene?.();

    // Deterministic ordering for stagger/VFX readability
    const targets = [...aliveTargets].sort((x,y)=>
      String(x.netId ?? x.name).localeCompare(String(y.netId ?? y.name))
    );

    // Index map for impact timing alignment
    const idxMap = new Map();
    targets.forEach((t,i)=>idxMap.set(t,i));

    const projMsRaw   = ((VFX?.PROJ_MS ?? 750) * 1.15);
    const projMs      = ms(projMsRaw);
    const impactDelay = Math.max(0, Math.floor(projMs * 0.90));
    const step        = ms(VFX?.AOE_STAGGER_MS ?? 140);

    // WHO is casting (overhead cue)
    vfxActCue?.(a, 'Plague');

    // --- VFX travel: prefer vfxCastToTargets; fallback to manual projectiles ---
    let usedAOEVFX = false;
    try {
      if (typeof vfxCastToTargets === 'function'){
        usedAOEVFX = true;
        vfxCastToTargets(a, targets, {
          label: '',
          proj: { ms: projMsRaw, color: 0x57ff7a, radius: 7 },
          onImpact: (t) => {
            // impact flash only (numbers/text handled below on the same timing)
            vfxFlashColor?.(t, { color: 0x57ff7a, ms: ms(350), alpha: 0.25 });
          },
          staggerMs: (VFX?.AOE_STAGGER_MS ?? 140)
        });
      }
    } catch { usedAOEVFX = false; }

    if (!usedAOEVFX){
  // fallback: still show travel from caster to each target
  try {
    targets.forEach((t, i) => {
      const startDelay = i * step;

      const doTravel = () => {
        // travel
        vfxProjectile?.(a, t, {
          ms: projMs,
          color: 0x57ff7a,
          radius: Math.floor(sc(7))
        });

        // impact happens when the projectile would reach the target
        const doImpact = () => {
          vfxFlashColor?.(t, { color: 0x57ff7a, ms: ms(350), alpha: 0.25 });
         
          // If you want the amount shown at impact, you need the dmg per target.
          // Option A (recommended): store it on the unit during the mechanics loop:
          //   t._plagueLastAmt = res.dmg;
          // then use it here:
          const amt = t._plagueLastAmt | 0;
          if (amt > 0){
           vfxFloatText?.(t, `-${amt} POISON`, {
  ms: ms(1100),
  fontSize: Math.floor(sc(16)),
  color: (VFX_COL?.poison || '#57ff7a')
});

          }

          // optional generic tag
          // vfxFloatText?.(t, `POISONED`, { ms: ms(650), fontSize: Math.floor(sc(14)), color: (VFX_COL?.poison || '#57ff7a') });
        };

        if (scene?.time?.delayedCall) scene.time.delayedCall(impactDelay, doImpact);
        else doImpact();
      };

      if (scene?.time?.delayedCall) scene.time.delayedCall(startDelay, doTravel);
      else doTravel();
    });
  } catch {}
}


    // --- Mechanics + impact-timed text ---
    for (const t of targets){
      const res = computeAbilityDamage(a, t, this);

      if (res.hit && !res.dodged && (res.dmg|0) > 0){
        // Mechanics: apply poison immediately (deterministic)
        addPoison(t, res.dmg, { silentVFX:true });

        // Log (immediate is fine; your UI is end-of-round-ish anyway)
        logGreen?.(`${t.name} is afflicted by a horrible plague (+${res.dmg}).`);

        // Cosmetic: show PLAGUE + -X POISON at the time the projectile *arrives*
        try {
          const i = idxMap.get(t);
          if (scene?.time?.delayedCall && i != null){
            const when = (i * step) + impactDelay;
            const amt  = res.dmg|0;
            scene.time.delayedCall(when, () => {
  vfxFloatText?.(t, `-${amt} POISON`, {
    ms: ms(1100),
    fontSize: Math.floor(sc(16)),
    color: (VFX_COL?.poison || '#57ff7a')
  });
});
          }
        } catch {}

      } else {
        appendLog?.(`${a.name}'s Plague misses ${t.name}.`);
      }
    }
  }
},

      {label:'Death Touch', desc:'Crush a third of the foe‚Äôs current life.', speed:'slow', type:'mag', target:'enemy',
        use:(a,t)=>{
          if (!t.alive()) return appendLog(`${t.name} is already down.`);
           const third = Math.floor(t.hp / 3);
        t.hp = clamp(t.hp - third, 0, t.maxHP);
         t._refresh && t._refresh(); checkHPWarnings(t);
        appendLogHTML(`<span style="color:#ff6b6b">${a.name} invokes Death Touch! ${t.name} loses ${third} HP.</span>`);
      }},


{label:'Plague Detonation', desc:'Consume all poison for an instant burst.', speed:'fast', type:'mag', target:'all-enemies',
  use:(a,arr)=>{
  let hits = 0;

  // Build detonation targets (COSMETIC ONLY)
  const detTargets = [];
  for (const t of arr){
    if (!t || !t.alive()) continue;
    const total = poisonTotal(t);
    if (total > 0) detTargets.push(t);
  }

  const idxMap = new Map();
  detTargets.forEach((t,i)=>idxMap.set(t,i));

  const scene = getScene();
  const projMs = vfxMs(((VFX?.PROJ_MS ?? 750) * 1.05));
  const impactDelay = Math.max(0, Math.floor(projMs * 0.90));
  const step = vfxMs(VFX?.AOE_STAGGER_MS ?? 140);

  // --- VFX ONLY: caster -> each poisoned target (GREEN, poison theme) ---
  try {
    vfxCastToTargets?.(a, detTargets, {
      label: 'Plague Detonation',
      proj: { ms: (VFX?.PROJ_MS ?? 750) * 1.05, color: 0x57ff7a, radius: 8 }, // GREEN
      onImpact: (t) => {
        vfxFlashColor?.(t, { color: 0x57ff7a, ms: 280, alpha: 0.30 }); // GREEN burst
        vfxShakePanel?.(t, { px: (VFX?.SHAKE_PX ?? 7), ms: vfxMs((VFX?.SHAKE_MS ?? 250) * 1.1) });
        // we'll show -dmg at impact below using the real computed dmg
      },
      staggerMs: (VFX?.AOE_STAGGER_MS ?? 140)
    });
  } catch {}

  // --- ORIGINAL MECHANICS (unchanged) ---
  for (const t of arr){
    if (!t.alive()) continue;

    const total = poisonTotal(t);
    if (total <= 0) continue;

    // consume poison first (unchanged)
    removeStatusKey(t,'poison');

    let dmg = Math.floor(total * (CONFIG.DAMAGE_GLOBAL||1));
    if (hasStatus(t,'marked')) dmg = Math.floor(dmg * (CONFIG.MARKED_MULT||1.25));

    const beforeHP = t.hp;
    t.hp = clamp(t.hp - dmg, 0, t.maxHP);

    t._refresh && t._refresh();
    if (typeof checkHPWarnings === 'function') checkHPWarnings(t);

    appendLogHTML(`<span style="color:#9be29b">${t.name} suffers ${dmg} from exploding plague.</span>`);

    // COSMETIC ONLY: show the burst number when the projectile reaches them
    try {
      const i = idxMap.get(t);
      if (scene?.time?.delayedCall && i != null){
        const when = (i * step) + impactDelay;
        const amt = dmg; // capture now
        scene.time.delayedCall(when, () => {
          vfxFloatText?.(t, `-${amt}`, { ms: vfxMs(VFX?.FLOAT_MS ?? 1250), fontSize: Math.floor(vfxScale(22)) });
          vfxFloatText?.(t, `DETONATE`, { ms: vfxMs(700), fontSize: Math.floor(vfxScale(14)) });
        });
      }
    } catch {}

    if (beforeHP > 0 && t.hp <= 0){
      appendLog(`‚ò† ${t.name} is down!`);
    }

    hits++;
  }

  if (!hits) appendLog(`No poisons to detonate.`);
}

}

    ];

    /* ===== Mystic ===== */
    case 'Mystic': return [
     {label:'Stun', desc:'Quickly stun your foe. 45% chance success.', speed:'fast', type:'mag', target:'enemy',
  use:(a,t)=>{
    if (!t?.alive?.()) return;

    // Always show that the spell was attempted (projectile + cue)
    vfxTryCastCC?.(a, t, 'stun');

    if (rand() < 0.45){
      const dur = ccDurBySDM(a);
      applyStatusWithLog(t, 'stun', dur, '#b084ff', `${a.name} stuns ${t.name} for {dur} rounds!`, a);
    } else {
      appendLog(`${a.name}'s Stun fails to take hold.`);

      // Optional: feedback on failure (purely cosmetic)
      vfxFlashColor?.(t, { color: 0xffffff, ms: vfxMs?.(180) ?? 180, alpha: 0.10 });
      vfxFloatText?.(t, 'RESIST!', { fontSize: 22, ms: vfxMs?.(650) ?? 650, color: '#d0d0d0' });
    }
  }
},

      {label:'Attack', desc:'Throwing dagger attack which can find weak spots.', speed:'normal', type:'phys', target:'enemy',
       base:{min:25,max:35}, scalesWith:'SDM', statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

     {label:'Berserk', desc:'Target attacks at random. 45% chance success.', speed:'normal', type:'mag', target:'enemy',
  use:(a,t)=>{
    if (!t?.alive?.()) return;

    // Always show that the spell was attempted (projectile + cue)
    vfxTryCastCC?.(a, t, 'berserk');

    if (rand() < 0.45){
      const dur = ccDurBySDM(a);
      applyStatusWithLog(t, 'berserk', dur, '#b084ff', `${a.name} drives ${t.name} absolutely berserk for {dur} rounds!`, a);
    } else {
      appendLog(`${a.name}'s Berserk fails to take hold.`);

      // Optional: feedback on failure (purely cosmetic)
      vfxFlashColor?.(t, { color: 0xffffff, ms: vfxMs?.(180) ?? 180, alpha: 0.10 });
      vfxFloatText?.(t, 'RESIST!', { fontSize: 22, ms: vfxMs?.(1250) ?? 650, color: '#d0d0d0' });
    }
  }
},

      {label:'Mental Breakdown', desc:'Crushing psychic blow.', speed:'slow', type:'mag', target:'enemy',
       base:{min:60,max:120}, scalesWith:'SDM', statCoef:0.55,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Premonition', desc:'All ally actions become fast next two rounds.', speed:'fast', type:'mag', target:'all-allies',
       use:(a,arr)=>{ for (const ally of arr){ if(ally.alive()) pushStatus(ally,{key:'premonition', dur:3}); }
         appendLogHTML(`${a.name} invokes <b>Premonition</b> ‚Äî your party acts fast next 2 rounds.`); } }
    ];

    default:
      return [
        {label:'Attack', desc:'A basic strike.', speed:'normal', type:u.kind==='mag'?'mag':'phys', target:'enemy',
         base:{min:20,max:25}, scalesWith:u.kind==='mag'?'SDM':'ATK', statCoef:0.35, isBasic:true,
         use:function(a,t){ return hit(a,t,{ability:this}); } }
      ];
  }
}

/* =========================
   VFX (COSMETIC ONLY)
   - No rand()
   - No game-state changes
   ========================= */

function getScene(){
  return (typeof sceneRef !== 'undefined' && sceneRef && sceneRef.add) ? sceneRef : null;
}

function panelCenterWorld(u){
  if (!u) return null;

  // --- Preferred: panel center (your current behavior) ---
  const panel = u?._ui?.panel;
  const scene = u?._ui?.scene || getScene();
  if (!scene) return null;

  const w = (scene.PANEL_W || 380);
  const h = (scene.PANEL_H || 120);

  if (panel){
    const localX = w * 0.5;
    const localY = h * 0.35;

    if (panel.getWorldTransformMatrix) {
      const m = panel.getWorldTransformMatrix();
      const out = { x: 0, y: 0 };
      m.transformPoint(localX, localY, out);
      return out;
    }
    return { x: panel.x + localX, y: panel.y + localY };
  }

  // --- Fallback: unit sprite/container position (COSMETIC ONLY) ---
  // Adjust this to match how you store sprites:
  const spr = u.sprite || u._sprite || u._ui?.sprite || null;
  if (spr && Number.isFinite(spr.x) && Number.isFinite(spr.y)){
    return { x: spr.x, y: spr.y };
  }

  return null;
}

function vfxShakePanel(u, { px=6, ms=160 } = {}){
  const scene = getScene();
  const panel = u?._ui?.panel;
  if (!scene || !panel) return;

  // prevent stacking drift
  scene.tweens.killTweensOf(panel);

  const x0 = panel.x, y0 = panel.y;
  scene.tweens.add({
    targets: panel,
    x: x0 + px,
    y: y0,
    duration: ms,
    yoyo: true,
    repeat: 2,
    ease: 'Sine.easeInOut',
    onComplete: () => { panel.x = x0; panel.y = y0; }
  });
}

function vfxFloatText(u, text, { ms=900, fontSize=22, color=null, stroke='#000000', rise=26, dx=0 } = {}){
  const scene = getScene();
  const pos = panelCenterWorld(u);
  if (!scene || !pos) return;

  // Normalize
  let s = String(text ?? '');

  // DEBUG: identify who is creating STUN/TAUNT pops
  if (/^(STUN|TAUNT)\b/i.test(s)) {
    console.log('[VFX DEBUG floatText]', s, 'on', u?.name || u);
    console.trace();
  }

  // --- COSMETIC ONLY: prevent identical text popping twice instantly on same unit ---
  const now = (scene.time && typeof scene.time.now === 'number') ? scene.time.now : Date.now();
  const k = s;

// Allow repeated numeric pops (damage/heal) ‚Äî they are satisfying and must not be deduped.
// Keep dedupe for labels like "COMBO!", "SHIFT", "CURED", etc.
const isNumericPop =
  /^\+\d+/.test(s) ||     // +12
  /^-\d+/.test(s)  ||     // -12
  /^-\d+/.test(s.replace(/^\+/, '-')); // safety, though redundant

const last = u._vfxTextLast || { t: -999999, k: '' };
const windowMs = (typeof vfxMs === 'function') ? vfxMs(140) : 140;

if (!isNumericPop) {
  if (last.k === k && (now - last.t) < windowMs) return;
  u._vfxTextLast = { t: now, k };
}

  // ‚úÖ SMART DEFAULTS when caller didn't pass a color
  if (!color) {
    if (/^\+\d+/.test(s)) color = (VFX_COL?.heal || '#57ff7a');                 // heals
    else if (/^-\d+/.test(s)) color = (VFX_COL?.dmg || '#ff6b6b');             // damage
    else color = '#ffffff';
  }

  // ‚úÖ Normalize poison application semantics: "+X POISON" -> "-X POISON"
  // (purely cosmetic; helps old callers you haven't found yet)
  if (/^\+\d+\s*POISON\b/i.test(s)) {
    s = s.replace(/^\+/, '-');
    if (!color || color === '#ffffff') color = (VFX_COL?.poison || '#57ff7a');
  }

  // small stack offset so multiple pops don't sit on top of each other
  u._vfxPopN = (u._vfxPopN || 0) + 1;
  const stackOffset = Math.min(3, u._vfxPopN - 1) * 14;

  const t = scene.add.text(pos.x + dx, pos.y - stackOffset, s, {
    fontFamily: 'monospace',
    fontSize: `${Math.floor((typeof vfxScale === 'function' ? vfxScale(fontSize) : fontSize))}px`,
    fontStyle: 'bold',
    color,
    stroke,
    strokeThickness: 4
  }).setOrigin(0.5, 0.5).setDepth(9999);

  scene.tweens.add({
    targets: t,
    y: t.y - rise,
    alpha: 0,
    duration: (typeof vfxMs === 'function') ? vfxMs(ms) : ms,
    ease: 'Quad.easeOut',
    onComplete: () => {
      t.destroy();
      u._vfxPopN = Math.max(0, (u._vfxPopN || 1) - 1);
    }
  });
}

function vfxProjectile(a, t, { ms=260, color=0xffffff, radius=5 } = {}){
  const scene = getScene();
  const from = panelCenterWorld(a);
  const to   = panelCenterWorld(t);

  if (!scene) { console.warn('[vfxProjectile] no scene'); return; }
  if (!from)  { console.warn('[vfxProjectile] no FROM for', a?.name || a); return; }
  if (!to)    { console.warn('[vfxProjectile] no TO for', t?.name || t); return; }

  // ... keep the rest exactly as you already have (including vfxMs/vfxScale if you added them)


  const g = scene.add.graphics()
    .setDepth(999998)     // just under float text
    .setScrollFactor(0);  // same camera safety

  g.fillStyle(color, 1);

  // Global scale knob applies here
  const r = Math.max(1, Math.floor(vfxScale(radius)));
  g.fillCircle(0, 0, r);

  g.x = from.x; g.y = from.y;

  // Global slow knob applies here
  const dur = vfxMs(ms);

  scene.tweens.add({
    targets: g,
    x: to.x,
    y: to.y,
    duration: dur,
    ease: 'Quad.easeInOut',
    onComplete: () => g.destroy()
  });
}

function vfxCastToTargets(caster, targets, {
  label = '',
  proj = { ms: 750, color: 0xffffff, radius: 6 },
  onImpact = null,
  staggerMs = 140
} = {}) {
  const scene = getScene?.();
  const list = (targets || []).filter(t => t);

  if (!scene || !list.length) return;

  const ms = (x) => (typeof vfxMs === 'function' ? vfxMs(x) : (x | 0));
  const step = ms(staggerMs | 0);

  // announce caster once (optional)
  try { if (caster && label) vfxActCue?.(caster, label); } catch {}

  // compute projectile duration + impact delay
  const projMs = ms(proj?.ms ?? 750);
  const impactDelay = Math.max(0, Math.floor(projMs * 0.90));

  // stable order (prevents random-looking AOE)
  const ordered = [...list].sort((a, b) =>
    String(a.netId ?? a.name ?? '').localeCompare(String(b.netId ?? b.name ?? ''))
  );

  ordered.forEach((t, i) => {
    const startDelay = i * step;

    const doTravel = () => {
      try {
        if (caster && caster !== t && typeof vfxProjectile === 'function') {
          vfxProjectile(caster, t, {
            ms: projMs,
            color: proj?.color ?? 0xffffff,
            radius: proj?.radius ?? 6
          });
        }
      } catch {}

      const doImpact = () => {
        if (label) {
  try {
    vfxFloatText?.(t, label, {
      ms: ms(850),
      fontSize: 14,
      color: hexToCss(proj?.color ?? 0xffffff)
    });
  } catch {}
}

        try { onImpact?.(t, i); } catch {}
      };

      if (scene?.time?.delayedCall) scene.time.delayedCall(impactDelay, doImpact);
      else doImpact();
    };

    if (scene?.time?.delayedCall) scene.time.delayedCall(startDelay, doTravel);
    else doTravel();
  });
}

function hexToCss(hex){
  return '#' + ((hex >>> 0).toString(16).padStart(6,'0'));
}

// Optional: call once to animate KO a little
function vfxKO(u){
  const scene = getScene();
  const panel = u?._ui?.panel;
  if (!scene || !panel) return;
  scene.tweens.add({
    targets: panel,
    alpha: { from: panel.alpha, to: 0.55 },
    duration: 120,
    ease: 'Quad.easeOut'
  });
}

// ---- make VFX functions global-safe (fixes delayedCall scope issues) ----
window.getScene        = window.getScene        || getScene;
window.panelCenterWorld= window.panelCenterWorld|| panelCenterWorld;

window.vfxFlashPanel   = window.vfxFlashPanel   || vfxFlashPanel;
window.vfxShakePanel   = window.vfxShakePanel   || vfxShakePanel;
window.vfxFloatText    = window.vfxFloatText    || vfxFloatText;
window.vfxProjectile   = window.vfxProjectile   || vfxProjectile;
window.vfxKO           = window.vfxKO           || vfxKO;

// if you use these too:
if (typeof vfxFlashColor === 'function') window.vfxFlashColor = window.vfxFlashColor || vfxFlashColor;
if (typeof vfxActCue    === 'function')  window.vfxActCue     = window.vfxActCue     || vfxActCue;

function vfxDamage(u, amount, { crit=false } = {}){
  const col = crit ? VFX_COL.crit : VFX_COL.dmg;
  vfxFloatText(u, `-${amount}`, { color: col, fontSize: crit ? 28 : 20, ms: (VFX?.FLOAT_MS ?? 1500) });
  vfxFlashPanel(u, { ms: (VFX?.FLASH_MS ?? 250) });
  vfxShakePanel(u, { px: (VFX?.SHAKE_PX ?? 6), ms: (VFX?.SHAKE_MS ?? 250) });
}

function vfxDodge(u){
  // dodge reads best as "blue ping + DODGE"
  vfxFlashColor?.(u, { color: 0x7ad7ff, ms: 260, alpha: 0.22 });
  vfxFloatText(u, `DODGE`, { color: VFX_COL.dodge, fontSize: 22, ms: 1500 });
}

function vfxStatus(u, key, { dur=null, kind='cc' } = {}){
  if (!u) return;

  const label = VFX_TEXT?.[key] || String(key || '').toUpperCase();
  const col =
    (key === 'poison') ? (VFX_COL?.poison || '#57ff7a') :
    (kind === 'cc')    ? (VFX_COL?.cc     || '#ff6bd6') :
    (kind === 'buff')  ? (VFX_COL?.buff   || '#a7c4ff') :
    (kind === 'debuff')? (VFX_COL?.debuff || '#ffb36b') :
                         '#ffffff';

  // flash color overlay + label pop
  const hex =
    (key === 'poison') ? 0x57ff7a :
    (kind === 'cc')    ? 0xff6bd6 :
    (kind === 'buff')  ? 0xa7c4ff :
    (kind === 'debuff')? 0xffb36b :
                         0xffffff;

  try {
    if (typeof vfxFlashColor === 'function'){
      vfxFlashColor(u, { color: hex, ms: vfxMs?.(260) ?? 260, alpha: 0.18 });
    } else {
      vfxFlashPanel?.(u, { ms: vfxMs?.(250) ?? 250 });
    }
  } catch {}

  // IMPORTANT: respect global tuning knobs
  vfxFloatText?.(u, dur ? `${label} (${dur})` : label, {
    color: col,
    fontSize: Math.floor((typeof vfxScale === 'function' ? vfxScale(18) : 18)),
    ms: (typeof vfxMs === 'function' ? vfxMs(1200) : 1200)
  });
}


function vfxHeal(u, amount, opts = {}){
  if (!u || !amount) return;

  const ms   = (x)=> (typeof vfxMs==='function' ? vfxMs(x) : (x|0));
  const sc   = (x)=> (typeof vfxScale==='function' ? vfxScale(x) : x);

  // Prefer your configured heal color, but always fall back to green
  const col = (VFX_COL?.heal || '#7CFF9A');

  vfxFlashColor?.(u, { color: 0x7CFF9A, ms: ms(opts.flashMs ?? 500), alpha: 0.14 });

  vfxFloatText?.(u, `+${amount|0}`, {
    color: col,                           // force a valid color
    fontSize: Math.floor(sc(opts.fontSize ?? 22)),
    ms: ms(opts.ms ?? 1500)
  });
}


/* ===== PART 2/4 ‚Äî ENGINE HELPERS ===== */
/* ---------- Status & stacking ---------- */
const STACKABLE = new Set(['atk_up','sdm_up','def_up','def_down']);

function hasStatus(u,key){ return u.status && u.status.some(s=>s.key===key); }

function countStacks(u, key){ let n=0; for(const s of (u.status||[])) if (s.key===key) n++; return n; }

function pushStatus(u, st, opts = null){
  if (!u || !st) return;
  if (!u.status) u.status = [];

  const showVFX = (opts && opts.showVFX === false) ? false : true;

  const key = st.key;
  // --- COSMETIC ONLY: de-dupe VFX for the same status key in the same moment ---
  const scene = getScene?.();
  const now = (scene?.time && typeof scene.time.now === 'number') ? scene.time.now : Date.now();
  const windowMs = (typeof vfxMs === 'function') ? (vfxMs(140) ?? 140) : 140;

  if (!u._statusVfxLast) u._statusVfxLast = {};
  const last = u._statusVfxLast[key] || -999999;
  const vfxAllowedThisCall = (now - last) >= windowMs;
  if (vfxAllowedThisCall) u._statusVfxLast[key] = now;

  let wasNew = false;
  let appliedDur = (st.dur|0);

  if (STACKABLE.has(key)) {
    const dur = Math.max(1, st.dur|0);
    u.status.push({ key, dur, data:{ stack:1 } });
    wasNew = true;
    appliedDur = dur;

  } else if (key === 'stun' || key === 'blind' || key === 'berserk' || key === 'taunt') {
    const existing = u.status.find(s => s.key === key);
    if (existing) {
      const cap = CONFIG.CC_MAX_CAP ?? 7;
      const add = Math.floor((st.dur|0) * 0.5);
      const before = existing.dur|0;
      existing.dur = Math.min(cap, (existing.dur|0) + add);
      appliedDur = existing.dur|0;
      wasNew = (existing.dur|0) > before;
    } else {
      u.status.push({ key, dur: (st.dur|0), data: st.data });
      wasNew = true;
      appliedDur = (st.dur|0);
    }

  } else {
    u.status.push(st);
    wasNew = true;
    appliedDur = (st.dur|0);
  }

  updateStatusView(u);

  // ‚úÖ VFX: only if allowed
    if (showVFX && wasNew && vfxAllowedThisCall && typeof vfxStatus === 'function') {
    try {
      if (key === 'poison') {
        vfxStatus(u, 'poison', { kind:'debuff' });
      } else if (key === 'stun' || key === 'taunt' || key === 'blind' || key === 'berserk') {
        vfxStatus(u, key, { dur: appliedDur, kind:'cc' });
      } else if (key === 'def_down' || key === 'marked') {
        vfxStatus(u, key, { dur: appliedDur, kind:'debuff' });
      } else if (key === 'def_up' || key === 'atk_up' || key === 'sdm_up' || key === 'guard' || key === 'divine_shield') {
        vfxStatus(u, key, { dur: appliedDur, kind:'buff' });
      }
    } catch {}
  }
}

function getUsesState(u){
  if (!u) return null;
  if (!u._abilityUses) u._abilityUses = {}; // usesKey -> usedCount
  return u._abilityUses;
}

function abilityUsesKey(u, ability){
  // Prefer explicit key so changing labels doesn't break.
  return ability?.usesKey || `${u?.job || 'Unit'}|${ability?.label || 'Ability'}`;
}

function getUsesUsed(u, ability){
  const max = ability?.usesMax | 0;
  if (!max) return 0;
  const st = getUsesState(u);
  const k = abilityUsesKey(u, ability);
  return (st?.[k] | 0);
}

function getUsesLeft(u, ability){
  const max = ability?.usesMax | 0;
  if (!max) return null; // unlimited
  return Math.max(0, max - getUsesUsed(u, ability));
}

function spendUse(u, ability){
  const max = ability?.usesMax | 0;
  if (!max) return true;
  const st = getUsesState(u);
  const k = abilityUsesKey(u, ability);
  const used = (st[k] | 0);
  if (used >= max) return false;
  st[k] = used + 1;
  return true;
}

function removeStatusKey(u, key){
  if (!u || !u.status) return false;
  const before=u.status.length; u.status=u.status.filter(s=>s.key!==key);
  if (u._refresh) u._refresh(); return u.status.length!==before;
}
function cleanseCCAndDebuffs(u){
  const toStrip=new Set(['stun','taunt','blind','berserk','def_down','poison','marked']);
  if (!u || !u.status) return false; const before=u.status.length;
  u.status=u.status.filter(s=>!toStrip.has(s.key)); if (u._refresh) u._refresh();
  return u.status.length!==before;
}

function syncDeathState(u){
  if (!u) return;
  if (u.hp > 0){
    // revived / alive again => allow future KO VFX to fire
    u._didKOVFX = false;
    u._deadLogged = false;
  }
}

function everyoneInNetOrder(){
  // IMPORTANT: these must always refer to the SAME TEAMS, not "my team"
  // You need references to hostTeamUnits and guestTeamUnits in your battle scene.
  const all = [...hostTeamUnits, ...guestTeamUnits].filter(u => u && u.alive());
  all.sort((a,b) => String(a.netId).localeCompare(String(b.netId)));
  return all;
}

/* ---------- Poison engine ---------- */
function addPoison(target, amount, opts = null){
  if (!target || amount <= 0) return;

  let st = target.status.find(s => s.key === 'poison');
  if (!st){
    st = { key:'poison', dur:9999, data:{ contributions:[] } };
    target.status.push(st);
  }

  const list = st.data.contributions || (st.data.contributions = []);
  list.push({ amt: Math.max(1, Math.floor(amount)) });

  updateStatusView(target);

  // If you call the base function directly (rare), allow silentVFX too:
  // (Normally the wrapper below handles VFX.)
  return { applied: true };
}

// --- COSMETIC ONLY wrapper (runs once) ---
if (typeof addPoison === 'function' && !addPoison._vfxWrapped){
  const _addPoison = addPoison;

  addPoison = function(target, amt, opts = null){
    const out = _addPoison(target, amt, opts); // mechanics unchanged

    // NEW: allow callers to suppress the default poison pop
    const silent = !!(opts && opts.silentVFX);

    if (!silent){
      try {
        if (target && amt > 0){
          vfxFlashColor?.(target, { color: 0x57ff7a, ms: 320, alpha: 0.24 });
          vfxFloatText?.(target, `POISONED`, {
            ms: vfxMs(650),
            fontSize: Math.floor(vfxScale(14)),
            color: (VFX_COL?.poison || '#57ff7a')
          });
        }
      } catch {}
    }

    return out;
  };

  addPoison._vfxWrapped = true;
}

function poisonTotal(u){
  const st = u.status.find(s => s.key === 'poison');
  const list = st?.data?.contributions;
  if (!Array.isArray(list) || !list.length) return 0;
  return list.reduce((s,c)=>s + (c.amt|0), 0);
}

/* ---------- durations & log helpers ---------- */
function buffDurBySDM(caster){
  const min=CONFIG.BUFF_BASE_MIN??2, max=CONFIG.BUFF_BASE_MAX??5, step=CONFIG.BUFF_SDM_PER_BONUS??15, cap=CONFIG.BUFF_MAX_CAP??6;
  const roll=min+randInt(0,Math.max(0,max-min)); const bonus=Math.floor(Math.max(0,caster?.SDM||0)/step);
  return Math.min(cap, roll+bonus);
}
function ccDurBySDM(caster){
  const min=CONFIG.CC_BASE_MIN??2, max=CONFIG.CC_BASE_MAX??5, step=CONFIG.CC_SDM_PER_BONUS??15, cap=CONFIG.CC_MAX_CAP??5;
  const roll=min+randInt(0,Math.max(0,max-min)); const bonus=Math.floor(Math.max(0,caster?.SDM||0)/step);
  return Math.min(cap, roll+bonus);
}

function applyHardCC(caster, target, key, dur, { data=null, showVFX=true } = {}) {
  if (!target) return false;

  // MECHANICS: apply status (SILENT so pushStatus won't do vfxStatus)
  if (data) pushStatus(target, { key, dur, data }, { showVFX:false });
  else      pushStatus(target, { key, dur },       { showVFX:false });

  // Get final applied duration (handles CC extension / cap logic in pushStatus)
  const appliedDur = (target.status?.find(s => s.key === key)?.dur | 0) || (dur|0);

  if (showVFX) {
    try {
      const scene = getScene?.();
      const delay = (typeof vfxMs === 'function') ? vfxMs(60) : 60;

      const doVFX = () => {
        // visuals only
        vfxHardCC?.(caster, target, key, { ms: 900, showOrigin: true });

        if (typeof vfxFlashColor === 'function') {
          vfxFlashColor(target, {
            color: (VFX?.CC_HEX ?? 0xb084ff),
            ms: (typeof vfxMs==='function' ? vfxMs(260) : 260),
            alpha: 0.20
          });
        }

        // SINGLE source of text (with duration)
        vfxStatus?.(target, key, { dur: appliedDur, kind: 'cc' });
      };

      if (scene?.time?.delayedCall) scene.time.delayedCall(delay, doVFX);
      else doVFX();
    } catch {}
  }

  return true;
}

function applyHardCC_AOE(caster, targets, key, dur, { showVFX=true } = {}) {
  const list = (targets || []).filter(t => t?.alive?.());
  if (!list.length) return 0;

  // MECHANICS: apply to everyone immediately (SILENT)
  for (const t of list) {
    pushStatus(t, { key, dur }, { showVFX:false });
  }

  if (showVFX) {
    try {
      // Keep projectiles, but DO NOT pass a label so vfxCastToTargets won't float text.
      vfxCastToTargets?.(caster, list, {
        label: '', // important: disables label float text inside vfxCastToTargets
        proj: { ms: (VFX?.PROJ_MS ?? 750) * 0.85, color: (VFX?.CC_HEX ?? 0xb084ff), radius: 7 },
        onImpact: (t) => {
          vfxHardCC?.(caster, t, key, { ms: 900, showOrigin: false });

          const appliedDur = (t.status?.find(s => s.key === key)?.dur | 0) || (dur|0);
          vfxStatus?.(t, key, { dur: appliedDur, kind: 'cc' });
        },
        staggerMs: (VFX?.AOE_STAGGER_MS ?? 150)
      });

      // Optional: show caster cue once (since label is blank now)
      // vfxActCue?.(caster, VFX_TEXT?.[key] || String(key).toUpperCase());
    } catch {}
  }

  return list.length;
}

function applyStatusWithLog(target, statusKey, dur, colorHex, text, caster=null) {
  // MECHANICS: apply status (SILENT so pushStatus won't do vfxStatus)
  pushStatus(target, { key: statusKey, dur }, { showVFX:false });

  // Get final applied duration (handles CC extension / cap logic in pushStatus)
  const appliedDur = (target.status?.find(s => s.key === statusKey)?.dur | 0) || (dur|0);

  const msg = (text && text.includes('{dur}'))
    ? text.replace('{dur}', appliedDur)
    : `${text || statusKey} (${appliedDur} rounds).`;

  const logCol =
    (statusKey === 'stun' || statusKey === 'blind' || statusKey === 'taunt' || statusKey === 'berserk')
      ? (VFX_COL?.cc || '#b084ff')
      : colorHex;

  appendLogHTML(`<span style="color:${logCol}">${msg}</span>`);

  // COSMETIC ONLY
  try {
    if (statusKey === 'stun' || statusKey === 'blind' || statusKey === 'taunt' || statusKey === 'berserk') {
      // visuals
      const scene = getScene?.();
      const d = vfxMs?.(120) ?? 120;
      const run = () => vfxHardCC?.(caster, target, statusKey, { ms: 1250, showOrigin: true });
      if (scene?.time?.delayedCall) scene.time.delayedCall(d, run);
      else run();

      // SINGLE source of text
      vfxStatus?.(target, statusKey, { dur: appliedDur, kind: 'cc' });
    } else {
      vfxStatus?.(target, statusKey, { dur: appliedDur, kind: 'debuff' });
    }
  } catch {}

  return appliedDur;
}

/* ---------- deterministic picks (no RNG before seeding) ---------- */
function pickCanonical(arr){
  if (!arr || !arr.length) return null;
  return [...arr].sort((a,b)=>{
    const A = String(a.netId ?? '');
    const B = String(b.netId ?? '');
    return A < B ? -1 : (A > B ? 1 : 0);
  })[0];
}
function pickDeterministic(arr){ return pickCanonical(arr); }


/* ---------- multipliers ---------- */
function atkMult(u){ const cfg=CONFIG.STACKS?.atk_up||{per:0.30,max:4}; const n=Math.min(countStacks(u,'atk_up'),cfg.max); return Math.pow(1+cfg.per, n); }
function sdmMult(u){ const cfg=CONFIG.STACKS?.sdm_up||{per:0.30,max:4}; const n=Math.min(countStacks(u,'sdm_up'),cfg.max); return Math.pow(1+cfg.per, n); }
function defMult(u){
  const upCfg=CONFIG.STACKS?.def_up||{per:0.30,max:4}, downCfg=CONFIG.STACKS?.def_down||{per:0.20,max:4};
  const upN=Math.min(countStacks(u,'def_up'),upCfg.max); const downN=Math.min(countStacks(u,'def_down'),downCfg.max);
  return Math.pow(1+upCfg.per, upN) * Math.pow(1-downCfg.per, downN);
}
function qknMult(u){
  // For now: no effects change QKN
  return 1;
}

/* ---------- combat math (damage) ---------- */
function critChance(attacker, type){
  const q=JOBS[attacker.job].QKN, it=JOBS[attacker.job].INT;
  const BASE=CONFIG.CRIT_BASE??0.05, CAP=CONFIG.CRIT_CAP??0.40;
  const PER_Q=CONFIG.CRIT_QKN_FACTOR??0.005, PER_I=CONFIG.CRIT_INT_FACTOR??0.005;
  let p = BASE + (type==='phys' ? q*PER_Q : it*PER_I);
  return Math.min(CAP, Math.max(0,p));
}
function tryDodge(attacker, defender, type){
  if(type!=='phys') return false;
  if (hasStatus(defender, 'shift')) return true;
  const q=JOBS[defender.job].QKN, base=CONFIG.DODGE_BASE??0.025, factor=CONFIG.DODGE_QKN_FACTOR??0.003, cap=CONFIG.DODGE_CAP??0.25;
  const p = Math.min(cap, Math.max(0, base + q*factor));
  return defender.alive() && chance(p);
}
function applyDefense(raw, defender, defPen=0){
  const effDEF=Math.max(0, defender.DEF*defMult(defender)*(1-defPen));
  const K=CONFIG.ARMOR_K??0.025; const red = effDEF/(effDEF+1/K);
  return Math.max(1, Math.floor(raw * (1 - red)));
}
function getAbilityType(attacker, ability){
  const forced=(ability&&ability.label&&window.ABILITY_TYPE_OVERRIDES[ability.label]);
  return (forced || ability?.type || (attacker?.kind || 'phys'));
}
function getAbilityScalesWith(attacker, ability, type){
  if (ability?.scalesWith) return ability.scalesWith;
  return (type==='mag')?'SDM':'ATK';
}
function abilityBasePower(ability){
  if (!ability) return 0;
  if (Number.isFinite(ability.power)) return ability.power|0;
  const b=ability.base||{min:0,max:0}, min=b.min|0, max=b.max|0;
  return min + randInt(0, Math.max(0, max - min));
}
function computeAbilityDamage(attacker, defender, ability){
  const type=getAbilityType(attacker,ability);
  const scalesWith=getAbilityScalesWith(attacker,ability,type);
  const statValue=(scalesWith==='SDM')?attacker.SDM:attacker.ATK;
  const offMult=(scalesWith==='SDM')?sdmMult(attacker):atkMult(attacker);
  const coef=Number.isFinite(CONFIG.STATCOEF_OVERRIDE)?CONFIG.STATCOEF_OVERRIDE:(ability?.statCoef??0);
  let dmg = Math.max(0, abilityBasePower(ability) + Math.floor(statValue * coef * offMult));
  if (type==='phys' && tryDodge(attacker, defender,'phys')) return {hit:false,dmg:0,crit:false,dodged:true,_type:type};
  let isCrit=false; const pCrit=Math.min(1, Math.max(0, critChance(attacker,type)+(ability?.critBonus??0)));
  if (chance(pCrit)){ dmg=Math.floor(dmg*1.75); isCrit=true; }
  const defPen=CONFIG.IGNORE_DEFPEN?0:(ability?.defPen||0);
  dmg=applyDefense(dmg, defender, defPen);
  if (!CONFIG.NO_GLOBAL_MULT) dmg=Math.floor(dmg*(CONFIG.DAMAGE_GLOBAL||1));
  return {hit:true,dmg,crit:isCrit,dodged:false,_type:type};
}

// HEALING MATH //

function computeAbilityHeal(caster, target, ability){
  // shape mirrors computeAbilityDamage, but positive and without defense
  const base = ability?.heal || { min:0, max:0 };
  const min = base.min|0, max = base.max|0;
  const roll = min + randInt(0, Math.max(0, max - min));

  const scalesWith = ability?.scalesWith || 'SDM';
  const statValue  = (scalesWith === 'SDM') ? caster.SDM : caster.ATK;

  const coef = Number.isFinite(ability?.healCoef) ? ability.healCoef : 0.0;

  // buffed stats affect heals too (SDM‚Üë/ATK‚Üë)
  const offMult = (scalesWith === 'SDM') ? sdmMult(caster) : atkMult(caster);

  let H = Math.max(0, roll + Math.floor(statValue * coef * offMult));

  if (!CONFIG.NO_GLOBAL_MULT) H = Math.floor(H * (CONFIG.DAMAGE_GLOBAL || 1));
  return H|0;
}

function applyHeal(caster, target, amount, { abilityName='Heal' } = {}){
  if (!caster || !target) return { healed:0 };
  if (amount <= 0) return { healed:0 };

  const before = target.hp;
  target.hp = clamp(target.hp + amount, 0, target.maxHP);
  const healed = target.hp - before;

  if (healed > 0){
  target._refresh && target._refresh();
  checkHPWarnings && checkHPWarnings(target);

  vfxHealImpact(caster, target, healed, abilityName);
}

  return { healed };
}

function vfxHealImpact(caster, target, healed, label = 'Heal') {
  if (!target || (healed | 0) <= 0) return;

  const ms = (x) => (typeof vfxMs === 'function' ? vfxMs(x) : (x | 0));

  // Match your heal green everywhere (VFX_COL.heal = '#57ff7a')
  const HEAL_HEX = 0x57ff7a;
  const HEAL_COL = (VFX_COL?.heal || '#57ff7a');

  // Who cast it (optional cue)
  try { if (caster) vfxActCue?.(caster, label); } catch {}

  // Travel caster -> target (optional)
  try {
    if (caster && caster !== target && typeof vfxProjectile === 'function') {
      vfxProjectile(caster, target, { ms: ms(360), color: HEAL_HEX, radius: 6 });
    }
  } catch {}

  // Impact flash + number
  try { vfxFlashColor?.(target, { color: HEAL_HEX, ms: ms(450), alpha: 0.18 }); } catch {}

  try {
    vfxFloatText?.(target, `+${healed | 0}`, {
      ms: ms(VFX?.FLOAT_MS ?? 1500),
      fontSize: 22,     // vfxFloatText scales internally
      color: HEAL_COL   // CSS string
    });
  } catch {}
}

window.testHealVFX = function(){
  const u = (player && player.find(x=>x && x.alive && x.alive())) || null;
  if (!u) return console.warn("No living player unit found for testHealVFX.");
  vfxHealImpact(u, u, 25, "Test Heal");
};

/* lightweight raw calc */
function calcDamage(a,t,opt){
  const type=opt.type||(a.kind==='mag'?'mag':'phys');
  const fakeAbility={ label:opt.verb||'Attack', type, base:{min:opt.baseMin??0,max:opt.baseMax??0},
    scalesWith:(type==='mag')?'SDM':'ATK', statCoef:Number.isFinite(CONFIG.STATCOEF_OVERRIDE)?CONFIG.STATCOEF_OVERRIDE:1.0 };
  const r=computeAbilityDamage(a,t,fakeAbility);
  return {hit:r.hit,dmg:r.dmg,crit:r.crit,dodged:r.dodged};
}

/* ---------- procs on basic ---------- */
function maybeProcOnBasic(attacker, target){
  const cfg = CONFIG.PROC?.[attacker.job];
  if (!cfg || rand() >= (cfg.chance ?? 0)) return;

  switch(attacker.job){

    /* =========================
       CLERIC PROC: self-heal
       ========================= */
    case 'Cleric': {
      const heal = Math.max(1, Math.floor((6 + randInt(0,5)) + attacker.SDM * 0.20));
      const total = Math.floor(heal * (CONFIG.DAMAGE_GLOBAL || 1));

      const before = attacker.hp;
      attacker.hp = clamp(attacker.hp + total, 0, attacker.maxHP);
      const healed = attacker.hp - before;

      attacker._refresh && attacker._refresh();
      checkHPWarnings(attacker);

      // VFX: heal indicator over cleric
      try {
        vfxActCue?.(attacker, 'Proc');
        // green flash overlay if you have vfxFlashColor
        vfxFlashColor?.(attacker, { color: 0xa7ffb5, ms: 450, alpha: 0.16 });
        vfxFloatText?.(attacker, `+${healed}`, { ms: (VFX?.FLOAT_MS ?? 1500), fontSize: 22 });
      } catch {}

      appendLogHTML(`<span style="color:#a7c4ff">‚ú® A prayer mends ${attacker.name} for ${healed}.</span>`);
      break;
    }

    /* =========================
       MAGE PROC: unchanged
       ========================= */
    case 'Mage': {
      const bolt = {label:'Lightning Bolt (proc)', type:'mag', speed:'fast', base:{min:10,max:20}, scalesWith:'SDM', statCoef:0.35, defPen:0.10};
      const r = computeAbilityDamage(attacker, target, bolt);
      if (r.hit){
        target.hp = clamp(target.hp - r.dmg, 0, target.maxHP);
        target._refresh && target._refresh();
        checkHPWarnings(target);
        appendLogHTML(`<span style="color:#a7c4ff">‚ö° A lightning bolt zaps ${target.name} for ${r.dmg}!</span>`);
      }
      break;
    }

    /* =========================
       MONK PROC: unchanged
       ========================= */
    case 'Monk': {
      const dur = buffDurBySDM(attacker);
      pushStatus(attacker, { key:'atk_up', dur });
      appendLogHTML(`<span style="color:#a7c4ff">üåÄ ${attacker.name} finds an opening: ATK‚Üë (${dur}).</span>`);
      break;
    }

    /* =========================
       MYSTIC PROC: unchanged
       ========================= */
    case 'Mystic': {
      if (!target || !target.alive()) return;
      const dur = buffDurBySDM(attacker);
      pushStatus(target, { key:'def_down', dur });
      appendLogHTML(`<span style="color:#a7c4ff">ü™Ñ ${target.name}'s guard falters: DEF‚Üì (${dur}).</span>`);
      break;
    }

    /* =========================
       NECROMANCER PROC: drain
       - damage pop over target
       - heal pop over necro
       - optional travel projectile + delayed impact
       ========================= */
    case 'Necromancer': {
      if (!target || !target.alive()) return;

      const drip = {label:'Life Drip (proc)', type:'mag', speed:'fast', base:{min:10,max:15}, scalesWith:'SDM', statCoef:0.30};
      const r = computeAbilityDamage(attacker, target, drip);

      // Miss/dodge
      if (!r.hit || r.dodged || (r.dmg|0) <= 0){
        // Optional: travel then dodge cue if it was a dodge
        try {
          if (r.dodged){
            const scene = getScene?.();
            const projMs = Math.floor((VFX?.PROJ_MS ?? 500) * 1.15);
            vfxActCue?.(attacker, 'Proc');
            vfxProjectile?.(attacker, target, { ms: projMs, color: 0xa7c4ff, radius: 6 });

            const impactDelay = Math.max(0, Math.floor(projMs * 0.75));
            const doDodge = () => vfxDodge?.(target);
            if (scene?.time?.delayedCall) scene.time.delayedCall(impactDelay, doDodge);
            else doDodge();
          }
        } catch {}

        appendLog(`${attacker.name}'s Life Drip fails to take hold.`);
        break;
      }

      const dealt = Math.max(1, r.dmg|0);

      const tBefore = target.hp;
      const aBefore = attacker.hp;

      target.hp = clamp(target.hp - dealt, 0, target.maxHP);
      attacker.hp = clamp(attacker.hp + dealt, 0, attacker.maxHP);

      const healed = attacker.hp - aBefore;

      target._refresh && target._refresh();
      attacker._refresh && attacker._refresh();
      checkHPWarnings(target);
      checkHPWarnings(attacker);

      // VFX: attacker cue -> travel -> delayed impact pops
      try {
        const scene = getScene?.();
        const projMs = Math.floor((VFX?.PROJ_MS ?? 500) * 1.15);
        const impactDelay = Math.max(0, Math.floor(projMs * 0.90));

        vfxActCue?.(attacker, 'Proc');
        vfxProjectile?.(attacker, target, { ms: projMs, color: 0xa7c4ff, radius: 6 });

        const finalT = target;
        const finalA = attacker;
        const crit   = !!r.crit;

        const doImpact = () => {
          // damage on target
          vfxFlashColor?.(finalT, { color: 0xa7c4ff, ms: 550, alpha: 0.18 });
          vfxFloatText?.(finalT, `-${dealt}`, { ms: (VFX?.FLOAT_MS ?? 900), fontSize: crit ? 28 : 20 });

          // heal on necro
          vfxFlashColor?.(finalA, { color: 0xa7ffb5, ms: 550, alpha: 0.16 });
          vfxFloatText?.(finalA, `+${healed}`, { ms: (VFX?.FLOAT_MS ?? 900), fontSize: 18 });

          // KO if this proc killed them
          if (tBefore > 0 && finalT.hp <= 0){
            appendLogHTML(`<span style="color:#ff6b6b">‚ò† ${finalT.name} is down!</span>`);
            if (!finalT._didKOVFX){ finalT._didKOVFX = true; vfxKO?.(finalT); }
            finalT._refresh?.();
          } else {
            finalT._didKOVFX = false;
          }
        };

        if (scene?.time?.delayedCall) scene.time.delayedCall(impactDelay, doImpact);
        else doImpact();
      } catch {}

      // Log text
      if (r.crit){
        appendLogHTML(`<span style="color:#a7c4ff">ü©∏ A <span style="color:gold">critical</span> sip steals ${dealt} from ${target.name}.</span>`);
      } else {
        appendLogHTML(`<span style="color:#a7c4ff">ü©∏ A dark sip steals ${dealt} from ${target.name}.</span>`);
      }

      break;
    }

    case 'Paladin': {
      const dur = buffDurBySDM(attacker);
      pushStatus(attacker, { key:'def_up', dur });
      appendLogHTML(`<span style="color:#a7c4ff">üõ°Ô∏è ${attacker.name}'s resolve hardens: DEF‚Üë (${dur}).</span>`);
      break;
    }
  }
}

/* ---------- status UI badges ---------- */
function updateStatusView(u){
  if (!u || !u._ui) return;
  const ui=u._ui, scene=ui.scene;

ui._statusTip ||= scene.add.text(0, 0, '', {
  fontSize: '12px',
  color: '#ffffff',
  backgroundColor: 'rgba(0,0,0,0.75)',
  padding: { x: 6, y: 3 }
})
.setOrigin(0, 1)
.setDepth(9999)
.setVisible(false);

  const effATK=u.ATK*atkMult(u), effSDM=u.SDM*sdmMult(u), effDEF=u.DEF*defMult(u);
  const baseQKN = (u.QKN ?? JOBS?.[u.job]?.QKN ?? 0);
const effQKN  = baseQKN * qknMult(u);

ui.statsTxt.setText(
  `ATK ${effATK.toFixed(1)}  ‚Ä¢  SDM ${effSDM.toFixed(1)}  ‚Ä¢  DEF ${effDEF.toFixed(1)}  ‚Ä¢  QKN ${effQKN.toFixed(0)}`
);

fitTextToWidth(ui.statsTxt, ui.statsMaxW, { minSize: 10 });

  ui.statusNodes ||= []; for (const n of ui.statusNodes) n.destroy(); ui.statusNodes.length=0;

  const ORDER=['shinobi_haste','invisible','bleed','shift','divine_shield','guard','shield_redirect','premonition','counter','poison','stun','taunt','blind','berserk','def_down','def_up','atk_up','sdm_up','marked','arcane_echo'];
  const present = ORDER.filter(key=>hasStatus(u,key)); if(!present.length) return;

  const ICON_SIZE=Math.max(8, parseInt(window.STATUS_ICON_SIZE??24,10)||24);
  const padX=Math.max(4,Math.round(ICON_SIZE*0.25)); const lineH=Math.max(18, ICON_SIZE+2);
  const startX=ui.badgeStartX??ui.baseX, startY=ui.badgeY??(ui.baseY+62), maxW=ui.badgeMaxW??(scene.PANEL_W-(ui.baseX*2));
  const labelFor = (key) => (
  key==='def_up'?'DEF‚Üë' :
  key==='def_down'?'DEF‚Üì' :
  key==='atk_up'?'ATK‚Üë' :
  key==='sdm_up'?'SDM‚Üë' :
  key==='guard'?'GUARD' :
  key==='divine_shield'?'SHIELD' :
  key==='shield_redirect'?'INTERCEPT' :
  key==='marked'?'MARKED' :
  key==='premonition'?'FAST' :
  key==='counter'?'COUNTER' :
  key==='arcane_echo'?'ECHO' :
  // NEW SHORT LABELS
  key==='shinobi_haste'?'HASTE' :
  key==='invisible'?'INVIS' :
  key==='shift'?'SHIFT' :
  key==='bleed'?'BLEED' :
  String(key || '').toUpperCase()
);

const statusTipFor = (key, u) => {
  // u is optional if you ever want dynamic text (stacks, values, etc.)
  switch (key) {
    case 'shift': return 'Shift: Cannot be targeted with physical.';
    case 'stun': return 'Stun: Cannot act.';
    case 'poison': return 'Poison: Takes damage each round.';
    case 'bleed': return 'Bleed: Takes physical % damage each round.';
    case 'berserk': return 'Berserk: Attack randomly.';
    case 'invisible': return 'Invisible: Targeted attacks miss.';
    case 'marked': return 'Marked: target takes 185% damage.';
    case 'shinobi_haste': return 'Shinobi Haste: +1 additional attack.';
    case 'arcane_echo': return 'Doublecast next spell with additional power.';
    case 'divine_shield': return 'Divine Shield: Protected from most damage.';
    case 'shield_redirect': return 'Shieldwall: Warrior intercepts his.';
    case 'premonition': return 'Premonition: Abilities cast fast.';
    case 'def_up': return 'DEF Up: Takes less damage.';
    case 'def_down': return 'DEF Down: Takes more damage.';
    case 'atk_up': return 'ATK Up: Deals more physical damage.';
    case 'sdm_up': return 'SDM Up: Deals more spell damage.';

    // fallback: just show the name if you haven't written a description yet
    default: return labelFor(key);
  }
};


  let used = 0, line = 0;
for (const key of present) {
  const texKey = `status_${key}`;
  let node, w = ICON_SIZE;

  if (scene.textures.exists(texKey)) {
    node = scene.add.image(0, 0, texKey).setOrigin(0, 0);
    node.setDisplaySize(ICON_SIZE, ICON_SIZE);
  } else {
    const fontPx = Math.max(12, Math.round(ICON_SIZE * 0.8));
    node = scene.add.text(0, 0, labelFor(key), { fontSize: `${fontPx}px`, color: '#dfe7ff' });
    w = node.width;
  }

  if (used > 0 && used + padX + w > maxW) {
    line++;
    if (line > 1) { node.destroy(); continue; }
    used = 0;
  }

  const x = startX + (used > 0 ? padX : 0) + used;
  const y = startY + (line * lineH);

  ui.panel.add(node);
  node.setPosition(x, y);
  ui.statusNodes.push(node);

  // -------- (2) Hover tooltip (name only) --------
  node.setInteractive({ useHandCursor: true });

  node.on('pointerover', (pointer) => {
    ui._statusTip.setText(statusTipFor(key, u));
    ui._statusTip.setVisible(true);

    // follow mouse
    ui._statusTip.setPosition(pointer.worldX + 10, pointer.worldY - 6);
  });

  node.on('pointermove', (pointer) => {
    if (!ui._statusTip.visible) return;
    ui._statusTip.setPosition(pointer.worldX + 10, pointer.worldY - 6);
  });

  node.on('pointerout', () => {
    ui._statusTip.setVisible(false);
  });

  // -------- stack count overlay --------
  if (STACKABLE.has(key)) {
    const n = countStacks(u, key);
    if (n > 1) {
      const sTxt = scene.add.text(0, 0, `√ó${n}`, {
        fontSize: `${Math.max(10, Math.round(ICON_SIZE * 0.6))}px`,
        color: '#ffd37a'
      });
      sTxt.setOrigin(1, 1);
      sTxt.setPosition(x + ICON_SIZE - 2, y + ICON_SIZE - 2);

      // -------- (3) Don't steal hover / clicks --------
      sTxt.disableInteractive?.();          // just in case
      sTxt.setInteractive = undefined;      // extra safety if you accidentally call it later
      // If you use input on top-only objects in your game, this also helps:
      // sTxt.setDepth(node.depth + 1);

      ui.panel.add(sTxt);
      ui.statusNodes.push(sTxt);
    }
  }

  used += (used > 0 ? padX : 0) + w;
}

}

/* ---------- end-of-round ticks & shrug ---------- */
const SHRUG_MESSAGES={ poison:(u)=>`${u.name} shrugs off the poison like it was nothing!`, stun:(u)=>`${u.name} snaps out of it and is no longer stunned!`, blind:(u)=>`${u.name} regains vision!`, berserk:(u)=>`${u.name}'s bloodlust wears off!`, def_down:(u)=>`${u.name} feels less vulnerable to attacks!` };
function tryShrug(u, key){
  if (!u || !key) return false;
  if (!hasStatus(u, key)) return false;

  const p = CONFIG.SHRUG_BASE ?? 0.05;
  const tgh = (u.TGH ?? u.tgh ?? 0);
  const extra = (CONFIG.SHRUG_TGH_FACTOR ?? 0.0025) * tgh;
  const chanceToShrug = Math.max(0, Math.min(0.95, p + extra));

  if (rand() >= chanceToShrug) return false;

  // remove (mechanics)
  removeStatusKey(u, key);
  updateStatusView?.(u);

  // cosmetic: log + VFX (once)
  const label =
    (VFX_TEXT && VFX_TEXT[key]) ? VFX_TEXT[key] :
    String(key).toUpperCase();

  appendLogHTML?.(`<span style="color:#7ad7ff">‚ú® ${u.name} shrugs off <b>${label}</b>!</span>`)
  || appendLog?.(`${u.name} shrugs off ${label}!`);

  vfxFlashColor?.(u, { color: 0x7ad7ff, ms: (typeof vfxMs==='function'? vfxMs(220):220), alpha: 0.18 });
  vfxFloatText?.(u, `SHRUG ${label}`, { ms: vfxMs?.(1500) ?? 900, fontSize: 16, color: (VFX_COL?.dodge || '#7ad7ff') });

  return true;
}

function applyHeal(caster, target, healSpecOrAbility, {
  label = 'Heal',
  showVFX = true,
  curePoison = false
} = {}){
  if (!target) return 0;

  const H = computeAbilityHeal(caster, target, healSpecOrAbility);
  const before = target.hp;

  target.hp = clamp(target.hp + H, 0, target.maxHP);

  // If we revived them elsewhere and they were at 0, your alive() may depend on hp>0.
  // This function does NOT auto-revive; it only heals.

  const healed = target.hp - before;

  if (curePoison) removeStatusKey(target, 'poison');

  target._refresh && target._refresh();
  if (typeof checkHPWarnings === 'function') checkHPWarnings(target);

  if (showVFX && healed > 0){
  vfxHealImpact(caster, target, healed, label);
}

  return healed;
}

console.log("[HEAL DEBUG] applyHeal active version:", applyHeal.toString().slice(0,120));

/* === CANONICAL ORDER HELPERS (host‚Üíguest, then by name) === */
function ensureUnitSides(){
  const mySide  = (PVP && PVP.role) || 'host';
  const oppSide = (mySide === 'host') ? 'guest' : 'host';
  for (const u of (player || [])) { if (u) u.side = mySide; }
  for (const u of (enemy  || [])) { if (u) u.side = oppSide; }
}

function canonicalKey(u){
  const side = u?.side || ((u?.team === 'player' ? PVP?.role : (PVP?.role === 'host' ? 'guest' : 'host')) || 'host');
  return `${side}|${u?.name || ''}`;
}

function canonicalUnits(){
  ensureUnitSides();
  const sideRank = { host: 0, guest: 1 };
  const all = [...(player || []), ...(enemy || [])];
  return all.slice().sort((a,b)=>{
    const sa = sideRank[a.side] ?? 0, sb = sideRank[b.side] ?? 0;
    if (sa !== sb) return sa - sb;
    const na = a.name || '', nb = b.name || '';
    return na.localeCompare(nb);
  });
}

function roundStateChecksum(){
  const all = canonicalUnits();
  const snap = all.map(u => ({
    k: canonicalKey(u),
    hp: u.hp|0,
    st: (u.status||[])
          .filter(s => s && s.key)
          .sort((a,b)=>a.key.localeCompare(b.key))
          .map(s => `${s.key}:${s.dur|0}`)
  }));
  const json = JSON.stringify(snap);
  return (fnv1a(json) >>> 0);
}

// ---- keeps KO/revive/KO consistent no matter what caused death ----
function syncDeathState(u){
  if (!u) return;

  const dead = (u.hp <= 0);

  if (dead){
    // latch KO VFX once per death event
    if (!u._didKOVFX){
      u._didKOVFX = true;
      if (typeof vfxKO === 'function') vfxKO(u);
    }
    // (optional) ensure UI reflects dead
    if (u._refresh) u._refresh();
  } else {
    // revived: clear latches so next KO can animate again
    if (u._didKOVFX) u._didKOVFX = false;
    if (u._deadLogged) u._deadLogged = false;
    if (u._refresh) u._refresh();
  }
}
window.syncDeathState = syncDeathState;

// =========================
// VFX VOCAB (colors/labels)
// =========================
const VFX_COL = {
  dmg:   '#ff6b6b',
  crit:  '#ffd37a',
  heal:  '#57ff7a',
  dodge: '#7ad7ff',
  cc:    '#b084ff',
  poison:'#57ff7a',
  buff:  '#a7c4ff',
  debuff:'#ffb36b',
  ko:    '#ff6b6b'
};

const VFX_TEXT = {
  stun:  'STUNNED',
  taunt: 'TAUNT',
  blind: 'BLIND',
  berserk:'BERSERK',
  poison:'POISON',
  guard:'GUARD',
  divine_shield:'SHIELD',
  def_up:'DEF‚Üë',
  def_down:'DEF‚Üì',
  atk_up:'ATK‚Üë',
  sdm_up:'SDM‚Üë',
  marked:'MARKED',
  counter:'COUNTER'
};

/* ---------- end-of-round ticks & shrug (canonical order) ---------- */
function endRoundTick(){
  const all = canonicalUnits();

  for (const u of all){
    if (!u.alive()) continue;

    // 1) Poison ticks
    const p = u.status.find(s => s.key === 'poison');
    if (p && Array.isArray(p.data?.contributions) && p.data.contributions.length){
      const current = p.data.contributions.reduce((s,c)=>s+(c.amt||0),0);
      if (current > 0){
        const poisonDealt = Math.floor(current * (CONFIG.DAMAGE_GLOBAL||1));

        const beforeHP = u.hp;
        u.hp = clamp(u.hp - poisonDealt, 0, u.maxHP);
        syncDeathState?.(u);

        vfxPoisonTick(u, poisonDealt);

        p.data.contributions = p.data.contributions
          .map(c => ({ amt: Math.floor(c.amt * 0.85) }))
          .filter(c => c.amt >= 1);

        const totalLeft = p.data.contributions.reduce((s,c)=>s + c.amt, 0);
        logGreen(`${u.name} takes ${poisonDealt} poison damage (${totalLeft} total).`);
        u._refresh && u._refresh();
        checkHPWarnings?.(u);

        if (beforeHP > 0 && u.hp <= 0 && !u._deadLogged){
          u._deadLogged = true;
          appendLogHTML(`‚ò† ${u.name} is down!`);
          removeStatusKey(u,'poison');
          updateStatusView(u);
          continue;
        }

        if (p.data.contributions.length === 0) removeStatusKey(u,'poison');
      }
    }

    // 2) Bleed ticks (end of round) ‚Äî NOT shrug-able
    const b = u.status.find(s => s.key === 'bleed');
    if (b && (b.dur|0) > 0){
      const pct = Number.isFinite(b.data?.pct) ? b.data.pct : 0.15;
      const bleedDealt = Math.max(1, Math.floor(u.hp * pct * (CONFIG.DAMAGE_GLOBAL || 1)));

      const beforeHP = u.hp;
      u.hp = clamp(u.hp - bleedDealt, 0, u.maxHP);
      syncDeathState?.(u);

      vfxFlashColor?.(u, { color: 0xff4d4d, ms: vfxMs(260), alpha: 0.26 });
      vfxFloatText?.(u, `-${bleedDealt} BLEED`, {
        ms: vfxMs(1600),
        fontSize: Math.floor(vfxScale(16)),
        color: '#ff7a7a'
      });

      appendLogHTML?.(`<span style="color:#ff7a7a">ü©∏ ${u.name} takes ${bleedDealt} bleed damage.</span>`);

      u._refresh && u._refresh();
      checkHPWarnings?.(u);

      if (beforeHP > 0 && u.hp <= 0 && !u._deadLogged){
        u._deadLogged = true;
        appendLogHTML(`‚ò† ${u.name} is down!`);
        removeStatusKey(u,'bleed');
        updateStatusView(u);
        continue;
      }
    }

// Track expiries BEFORE we decrement
const hadBleed  = hasStatus(u, 'bleed');
const hadHaste  = hasStatus(u, 'shinobi_haste');
const hadStun   = hasStatus(u, 'stun');
const hadTaunt  = hasStatus(u, 'taunt');
const hadBerserk= hasStatus(u, 'berserk');

// Decrement durations (except poison)
for (const st of u.status){ if (st.key !== 'poison') st.dur--; }
u.status = u.status.filter(s=>s.dur > 0);

// If Bleed expired this tick, announce it (cosmetic only)
if (hadBleed && !hasStatus(u, 'bleed')){
  appendLogHTML?.(`<span style="color:#ffb3b3">ü©∏ Bleed wears off of ${u.name}.</span>`);
  if (!appendLogHTML) appendLog(`Bleed wears off of ${u.name}.`);

  // optional tiny VFX tag
  vfxFloatText?.(u, `BLEED END`, {
    ms: (typeof vfxMs==='function' ? vfxMs(1500) : 900),
    fontSize: 16,
    color: '#ffb3b3'
  });
}

// If Shinobi Haste expired this tick, announce it (cosmetic only)
if (hadHaste && !hasStatus(u, 'shinobi_haste')){
  appendLogHTML?.(`<span style="color:#c9c9ff">üí® Thief's Haste wears off of ${u.name}.</span>`)
  || appendLog?.(`Thief's Haste wears off of ${u.name}.`);

  // optional tiny VFX tag
  vfxFloatText?.(u, `HASTE END`, {
    ms: (typeof vfxMs==='function' ? vfxMs(1500) : 900),
    fontSize: 16, // let vfxFloatText scale once
    color: '#c9c9ff'
  });
}

// ---- CC expiries (natural duration expiry, not shrug) ----
if (hadStun && !hasStatus(u, 'stun')){
  appendLogHTML?.(`<span style="color:${VFX_COL?.cc || '#b084ff'}">‚ú® Stun wears off of ${u.name}.</span>`)
  || appendLog?.(`Stun wears off of ${u.name}.`);

  vfxFloatText?.(u, `STUN END`, {
    ms: vfxMs?.(1500) ?? 900,
    fontSize: 16,
    color: (VFX_COL?.cc || '#b084ff')
  });
}

if (hadTaunt && !hasStatus(u, 'taunt')){
  appendLogHTML?.(`<span style="color:${VFX_COL?.cc || '#b084ff'}">‚ú® Taunt wears off of ${u.name}.</span>`)
  || appendLog?.(`Taunt wears off of ${u.name}.`);

  vfxFloatText?.(u, `TAUNT END`, {
    ms: vfxMs?.(1500) ?? 900,
    fontSize: 16,
    color: (VFX_COL?.cc || '#b084ff')
  });
}

if (hadBerserk && !hasStatus(u, 'berserk')){
  appendLogHTML?.(`<span style="color:${VFX_COL?.cc || '#b084ff'}">‚ú® Berserk wears off of ${u.name}.</span>`)
  || appendLog?.(`Berserk wears off of ${u.name}.`);

  vfxFloatText?.(u, `BERSERK END`, {
    ms: vfxMs?.(1500) ?? 900,
    fontSize: 16,
    color: (VFX_COL?.cc || '#b084ff')
  });
}

    // 4) Shrug checks (bleed intentionally NOT included)
    if (hasStatus(u,'poison'))   tryShrug(u,'poison');
    if (hasStatus(u,'stun'))     tryShrug(u,'stun');
    if (hasStatus(u,'blind'))    tryShrug(u,'blind');
    if (hasStatus(u,'berserk'))  tryShrug(u,'berserk');
    if (hasStatus(u,'def_down')) tryShrug(u,'def_down');

    updateStatusView(u);
  }
}

function vfxTryCastCC(caster, target, key, { ms=null, showOrigin=true } = {}) {
  if (!caster || !target) return;
  const hex = (VFX?.CC_HEX ?? 0xb084ff);

  // show caster cue (spell name)
  vfxActCue?.(caster, VFX_TEXT?.[key] || String(key||'SPELL').toUpperCase());

  // always show projectile to indicate attempt
  if (showOrigin) {
    vfxProjectile?.(caster, target, {
      ms: vfxMs?.(ms ?? ((VFX?.PROJ_MS ?? 750) * 0.90)) ?? (ms ?? ((VFX?.PROJ_MS ?? 750) * 0.90)),
      color: hex,
      radius: Math.floor((typeof vfxScale === 'function' ? vfxScale(6) : 6))
    });
  }
}

function vfxHardCC(caster, target, key, { ms=900, showOrigin=true, showText=false } = {}) {
  if (!target) return;

  // --- COSMETIC ONLY: de-dupe hard CC on same unit/key in the same moment ---
  const scene = getScene?.();
  const now = (scene?.time && typeof scene.time.now === 'number') ? scene.time.now : Date.now();
  const kk = `cc:${key}`;
  const last = target._vfxCCLast || { t: -999999, k: '' };
  const windowMs = vfxMs?.(180) ?? 180;
  if (last.k === kk && (now - last.t) < windowMs) return;
  target._vfxCCLast = { t: now, k: kk };

  const label =
    (key === 'stun')    ? (VFX_TEXT?.stun    || 'STUNNED') :
    (key === 'blind')   ? (VFX_TEXT?.blind   || 'BLIND') :
    (key === 'berserk') ? (VFX_TEXT?.berserk || 'BERSERK') :
    (key === 'taunt')   ? (VFX_TEXT?.taunt   || 'TAUNT') :
                          (VFX_TEXT?.[key]   || String(key||'STATUS').toUpperCase());

  const hex     = (VFX?.CC_HEX ?? 0xb084ff);      // purple
  const textCol = (VFX_COL?.cc ?? '#b084ff');     // purple text

  // show WHO cast it (OPTIONAL)
  if (showText && caster) {
    try { vfxActCue?.(caster, label); } catch {}
  }

  // caster -> target motion (optional)
  try {
    if (showOrigin && caster && typeof vfxProjectile === 'function') {
      vfxProjectile(caster, target, {
        ms: vfxMs?.((VFX?.PROJ_MS ?? 750) * 0.90) ?? ((VFX?.PROJ_MS ?? 750) * 0.90),
        color: hex,
        radius: Math.floor((typeof vfxScale === 'function' ? vfxScale(6) : 6))
      });
    }
  } catch {}

  // impact language on target (visuals always; text optional)
  try {
    vfxFlashColor?.(target, { color: hex, ms: vfxMs?.(320) ?? 320, alpha: 0.26 });
    vfxShakePanel?.(target, {
      px: Math.floor((VFX?.SHAKE_PX ?? 7) * 1.0),
      ms: vfxMs?.((VFX?.SHAKE_MS ?? 250) * 1.05) ?? ((VFX?.SHAKE_MS ?? 250) * 1.05)
    });

    if (showText) {
      vfxFloatText?.(target, label, {
        ms: vfxMs?.(ms) ?? ms,
        fontSize: Math.floor((typeof vfxScale === 'function' ? vfxScale(16) : 16)),
        color: textCol
      });
    }
  } catch {}
}


function vfxPoisonTick(u, amount){
  vfxFlashColor(u, { color: 0x57ff7a, ms: vfxMs(300), alpha: 0.40 });
  vfxFloatText(u, `-${amount} POISON`, {
    ms: vfxMs(1250),
    fontSize: Math.floor(vfxScale(18)),
    color: (VFX_COL?.poison || '#57ff7a')
  });
}

function vfxFlashColor(u, { ms=225, color=0x57ff7a, alpha=0.35 } = {}){
  const scene = getScene?.();
  const panel = u?._ui?.panel;
  if (!scene || !panel) return;

  const w = scene.PANEL_W || 380;
  const h = scene.PANEL_H || 120;

  // Graphics overlay inside the unit's panel container
  const g = scene.add.graphics().setDepth(9997);
  g.fillStyle(color, 1);
  g.fillRect(0, 0, w, h);
  g.setAlpha(alpha);
  g.disableInteractive?.();

  // Attach to panel so it moves with shakes, etc.
  panel.add(g);

  scene.tweens.add({
    targets: g,
    alpha: 0,
    duration: (typeof vfxMs === 'function' ? vfxMs(ms) : ms),
    ease: 'Quad.easeOut',
    onComplete: () => g.destroy()
  });
}

function vfxActCue(u, label, { ms = VFX.ACT_FLASH_MS } = {}){
  if (!u) return;

  // --- COSMETIC ONLY: prevent duplicate act cues in the same moment ---
  const scene = getScene?.();
  const now = (scene?.time && typeof scene.time.now === 'number') ? scene.time.now : Date.now();
  const key = `${label || ''}`;

  const last = u._vfxActCueLast || { t: -999999, key: '' };
  const windowMs = vfxMs ? vfxMs(140) : 140;
  if (last.key === key && (now - last.t) < windowMs) return;
  u._vfxActCueLast = { t: now, key };

  // --- SAFE calls (never crash gameplay if VFX helpers aren't loaded yet) ---
  try {
    // flash if available
    if (typeof vfxFlashColor === 'function'){
      vfxFlashColor(u, { color: 0xa7c4ff, ms: (typeof vfxMs === 'function' ? vfxMs(ms) : ms), alpha: 0.18 });
    } else if (typeof vfxFlashPanel === 'function'){
      vfxFlashPanel(u, { ms: (typeof vfxMs === 'function' ? vfxMs(ms) : ms) });
    }

    // label float if available
    if (label && typeof vfxFloatText === 'function'){
      vfxFloatText(u, label, {
        ms: (typeof vfxMs === 'function' ? vfxMs(700) : 700),
        fontSize: (typeof vfxScale === 'function' ? Math.floor(vfxScale(14)) : 14)
      });
    }
  } catch {}
}


/* ---------- team accessor ---------- */
function teamArray(team){ return team==='player' ? player : enemy; }

const VFX = {
  PROJ_MS: 750,
  SHAKE_MS: 250,
  SHAKE_PX: 7,
  FLASH_MS: 250,
  FLOAT_MS: 1750,
  ACT_FLASH_MS: 500,

  // Global knobs (COSMETIC ONLY)
  TIME_SCALE: 1.85,
  GLOBAL_SCALE: 1.20,
  AOE_STAGGER_MS: 150,
  STATUS_TO_HEAL_MS: 125,

  // Hard CC language
  CC_HEX: 0xb084ff
};



function vfxMs(ms){
  return Math.max(0, Math.floor(ms * (VFX?.TIME_SCALE ?? 1)));
}

function vfxScale(n){
  return n * (VFX?.GLOBAL_SCALE ?? 1);
}

function vfxFlashPanel(u, { ms=120 } = {}){
  const scene = getScene();
  const panel = u?._ui?.panel;
  if (!scene || !panel) return;

  scene.tweens.add({
    targets: panel,
    alpha: { from: 1, to: 0.35 },
    duration: vfxMs(ms),
    yoyo: true,
    ease: 'Quad.easeOut'
  });
}

 
/* ---------- core hit() ---------- */
function hit(a, t, opt={}, verb){
  if (hasStatus(a,'stun')){
    appendLog(`${a.name} is stunned and cannot act.`);
    return {dealt:0,dodged:false,crit:false};
  }

  const ability = opt.ability;
  // --- COSMETIC ONLY VFX overrides ---
  const vfxFrom = opt.vfxFrom || a;            // projectile origin override (for chain lightning)
  const noActCueVFX = !!opt.noActCueVFX;       // suppress vfxActCue in hit()
  const noProjectileVFX = !!opt.noProjectileVFX; // suppress projectile travel in hit()

  const looksLikeAbility = ability && (ability.base || ability.statCoef!==undefined || ability.defPen!==undefined || ability.isBasic);
  let target = t;

  // Shieldwall redirect (first single-target hit)
  const wantsST = ability && ability.target === 'enemy';
  if (wantsST && !opt._noRedirect && t && t.team){
    const pool = teamArray(t.team);
    const guardian = pool.find(u => u!==t && u.alive() && hasStatus(u,'shield_redirect'));
    if (guardian){
      const st = guardian.status.find(s=>s.key==='shield_redirect');
      if (st && (st.data ?? (st.data = {}))){
        st.data.remaining = (st.data.remaining ?? 1) - 1;
        if (st.data.remaining <= 0) removeStatusKey(guardian,'shield_redirect');
      }
      appendLogHTML(`${guardian.name} <span style="color:#a7c4ff">intercepts</span> the blow for ${t.name}!`);
      target = guardian;
    }
  }

  const res = looksLikeAbility ? computeAbilityDamage(a,target,ability) : calcDamage(a,target,opt);
  const abilityName = (a._usingAbilityLabel || (verb ? verb : (ability ? ability.label : (opt.type==='mag'?'spell':'attack'))));

  if (res.dodged){
  const abType = res?._type || getAbilityType(a, ability);
  const isMag  = (abType === 'mag');
  const projMs = isMag ? Math.floor((VFX?.PROJ_MS ?? 260) * 1.15) : (VFX?.PROJ_MS ?? 260);
  const projColor  = isMag ? 0xa7c4ff : 0xffffff;
  const projRadius = isMag ? 6 : 5;

  if (!noActCueVFX) vfxActCue?.(a, abilityName);
  if (!noProjectileVFX) vfxProjectile(vfxFrom, target, { ms: projMs, color: projColor, radius: projRadius });


  const scene = getScene();
  const impactDelay = Math.max(0, Math.floor(projMs * 0.75));
  const doDodge = () => (typeof vfxDodge === 'function') && vfxDodge(target);


  if (scene?.time?.delayedCall) scene.time.delayedCall(impactDelay, doDodge);
  else doDodge();

  appendLogHTML(`${target.name} <span style="color:skyblue">dodges</span> ${a.name}‚Äôs ${abilityName}!`);
  return {dealt:0,dodged:true,crit:false};
}

  let dmgToApply = res.dmg;
  if (a._echoing) dmgToApply = Math.floor(dmgToApply * (a._echoMult || CONFIG.ECHO_MULT || 1.05));
  if (opt.dmgMult) dmgToApply = Math.floor(dmgToApply * opt.dmgMult);

  if (hasStatus(target,'divine_shield') && dmgToApply>0){
    appendLogHTML(`${target.name} is protected by <span style="color:#ffd700">Divine Shield</span>! No damage taken.`);
    dmgToApply = 0;
  }
  if (hasStatus(target,'marked') && dmgToApply>0){
    dmgToApply = Math.floor(dmgToApply*(CONFIG.MARKED_MULT||1.8));
  }
  if (hasStatus(target,'guard') && dmgToApply>0){
    const pctFromStatus = target.status.find(s=>s.key==='guard')?.data?.pct;
    const guardPct = Number.isFinite(pctFromStatus) ? pctFromStatus : (window.GUARD_REDUCTION ?? 0.5);
    const clamped = Math.max(0, Math.min(0.95, guardPct));
    const reduced = Math.floor(dmgToApply*(1-clamped));
    const saved = dmgToApply - reduced;
    dmgToApply = reduced;
    if (saved>0) appendLogHTML(`${target.name} <span style="color:#a7c4ff">guards</span>, mitigating ${saved} damage.`);
  }

  // apply damage
  target.hp = clamp(target.hp - dmgToApply, 0, target.maxHP);
  target._refresh && target._refresh();
  checkHPWarnings(target);

// ---- VFX: travel ‚Üí impact (ONLY ONCE) ----
if (dmgToApply > 0){

  // Decide ‚Äúspell vs phys‚Äù feel from the already-computed result
  const abType = (res && res._type) ? res._type : getAbilityType(a, ability);
  const isMag  = (abType === 'mag');

  const projMs     = isMag ? Math.floor((VFX?.PROJ_MS ?? 400) * 1.15) : (VFX?.PROJ_MS ?? 400);
  const projColor  = isMag ? 0xa7c4ff : 0xffffff;
  const projRadius = isMag ? 6 : 5;

    if (!noActCueVFX){
    if (typeof vfxActCue === 'function') vfxActCue(a, abilityName);
    else if (typeof vfxFlashColor === 'function') vfxFlashColor(a, { color: 0xa7c4ff, ms: (VFX?.ACT_FLASH_MS ?? 300), alpha: 0.18 });
    else if (typeof vfxFlashPanel === 'function') vfxFlashPanel(a, { ms: (VFX?.ACT_FLASH_MS ?? 300) });
  }

  if (!noProjectileVFX && typeof vfxProjectile === 'function'){
    vfxProjectile(vfxFrom, target, { ms: projMs, color: projColor, radius: projRadius });
  }

  // 3) impact after travel (so it‚Äôs readable)
  const impactDelay = Math.max(0, Math.floor(projMs * 0.90));
  const scene = getScene();

  // capture values now so delayed callback cannot drift
  const finalTarget = target;
  const amount      = dmgToApply;
  const crit        = !!res.crit;

    const doImpact = () => {
    if (typeof vfxDamage === 'function'){
      vfxDamage(finalTarget, amount, { crit });
      return;
    }
    vfxShakePanel?.(finalTarget, { px: (VFX?.SHAKE_PX ?? 6), ms: vfxMs(VFX?.SHAKE_MS ?? 220) });
    vfxFlashPanel?.(finalTarget, { ms: vfxMs(VFX?.FLASH_MS ?? 250) });

    vfxFloatText?.(finalTarget, `-${amount}`, {
      ms: vfxMs(VFX?.FLOAT_MS ?? 1500),
      fontSize: Math.floor(vfxScale(crit ? 28 : 20)),
      color: crit ? (VFX_COL?.crit || '#ffd37a') : (VFX_COL?.dmg || '#ff6b6b')
    });
  };

  if (scene?.time?.delayedCall) scene.time.delayedCall(impactDelay, doImpact);
  else doImpact();
}


// ---- Combat log ----
if (abilityName.toLowerCase()==='attack'){
  if (res.crit) appendLogHTML(`${a.name}‚Äôs attack lands a <span style="color:gold">critical strike</span>! ${target.name} takes ${dmgToApply} damage.`);
  else          appendLog(`${a.name} attacks ${target.name} for ${dmgToApply} damage.`);
} else {
  if (res.crit) appendLogHTML(`${a.name}‚Äôs ${abilityName} lands a <span style="color:gold">critical strike</span>! ${target.name} takes ${dmgToApply} damage.`);
  else          appendLog(`${a.name} uses ${abilityName}. ${target.name} takes ${dmgToApply} damage.`);
}

// ---- KO handling (one-time VFX per death, supports revive) ----
if (dmgToApply > 0 && target.hp <= 0){
  appendLogHTML(`<span style="color:#ff6b6b">‚ò† ${target.name} is down!</span>`);

  if (!target._didKOVFX){
    target._didKOVFX = true;
    vfxKO(target);
  }

  if (target._ui) target._refresh && target._refresh();
} else {
  // only clear latch when they're actually alive again
  if (target.hp > 0 && target._didKOVFX) target._didKOVFX = false;
}

// ---- Basic-attack proc (only if target survived) ----
if (ability?.isBasic && dmgToApply > 0 && target.alive()){
  maybeProcOnBasic(a, target);
}

  if (!opt._noCounter && target.alive() && a.alive() && hasStatus(target,'counter')){
    const counter = {label:'Counter', type:'phys', target:'enemy', base:{min:8,max:14}, scalesWith:'ATK', statCoef:(CONFIG.COUNTER_COEF||0.30)};
    const oldLabel = target._usingAbilityLabel;
    target._usingAbilityLabel = 'Counter';
    hit(target, a, {ability:counter, _noCounter:true, _noRedirect:true}, 'counterstrikes');
    target._usingAbilityLabel = oldLabel;
  }

  return {dealt:dmgToApply, dodged:false, crit:res.crit};
}

/* ===== PART 3/4 ‚Äî Parties, UI, Scene, Round ===== */

/* ---------- Parties & round state ---------- */
function pickRandomJobs(n){ const pool=[...ALL_CLASSES], picks=[]; for(let i=0;i<n&&pool.length>0;i++){ const idx=Math.floor(rand()*pool.length); picks.push(pool[idx]); pool.splice(idx,1);} return picks;}
function createParty(teamName){ return pickRandomJobs(3).map(job=>makeUnit(job,teamName)); }

let player = [];   // PvP: start empty until draft completes
let enemy  = [];

let selectingIndex = 0;
let playerChoices  = [];
let enemyChoices   = [];
let roundNumber    = 1;

function resetRoundState(){
  selectingIndex = 0;
  playerChoices  = [];
  enemyChoices   = [];
  _pendingAbility = null;
  _pendingTargetPick = false;
  _pendingAbilityTarget = null;
}

/* ---------- selection helpers ---------- */
const SPEED_RANK = { fast:0, normal:1, slow:2 };
const allAlive = (arr)=> arr.filter(u=>u.alive());
function currentActor(){ const alive = player.filter(u => u.alive()); return alive[selectingIndex] || null; }

function setTopBarTitle(text, color = '#e8e8f0'){
  if (!topLeftEl) return;
  topLeftEl.textContent = text;
  topLeftEl.style.color = color;
}

function setTopBarLobby(){
  setTopBarTitle('Realm of Shinobi: Tournament of Legends', '#a7c4ff');
}

/* ---------- target pick UI ---------- */
let _pendingAbility = null;
let _pendingTargetPick = false;
let _pendingAbilityTarget = null;

function updateTopBarForCurrentSelection(){
  // If we‚Äôre in the lobby, force the title (no round text)
  if (PVP && PVP.phase === 'idle'){
    setTopBarLobby();
    return;
  }

  const actor = currentActor();
  if (!actor){
    topLeftEl.textContent = `Round ${roundNumber} ‚Äî Waiting‚Ä¶`;
    return;
  }

  if (_pendingTargetPick && _pendingAbility){
    const tgtWord =
      _pendingAbilityTarget === 'ally'  ? 'an ally'  :
      _pendingAbilityTarget === 'enemy' ? 'an enemy' :
      'a target';

    const abLabel = _pendingAbility.label || 'ability';

    topLeftEl.textContent =
      `Round ${roundNumber} ‚Äî Select ${tgtWord} for ${actor.name}'s ${abLabel}`;
    return;
  }

  const ta = actor.status?.find(s=>s.key==='taunt' && s.dur>0 && s.data?.taunter?.alive());
  if (ta){
    topLeftEl.textContent = `Round ${roundNumber} ‚Äî ${actor.name} is taunted: must Attack ${ta.data.taunter.name}`;
    return;
  }

  topLeftEl.textContent = `Round ${roundNumber} ‚Äî Choose action for ${actor.name}`;
}

function fitTextToWidth(txtObj, maxW, { minSize=10 } = {}) {
  if (!txtObj || !maxW) return;
  let size = parseInt(txtObj.style.fontSize, 10) || 14;

  // reset to starting size if you want (optional)
  // size = 14; txtObj.setFontSize(size);

  while (txtObj.width > maxW && size > minSize) {
    size -= 1;
    txtObj.setFontSize(size);
  }
}

function enterLobbyUI(){
  // Top bar title for the lobby
  if (topLeftEl) topLeftEl.textContent = 'Realm of Shinobi: Tournament of Legends';

  // Clear action bars
  if (typeof clearActionBar === 'function') clearActionBar();
  const right = document.getElementById('action-bar-right');
  if (right) right.textContent = '';

  // Clear any leftover unit rows from the last battle (keep background)
  if (sceneRef){
    try{
      sceneRef.playerCol && sceneRef.playerCol.removeAll(true);
      sceneRef.enemyCol  && sceneRef.enemyCol.removeAll(true);
    }catch(_){}
  }
}

/* ---------- enemy AI (SP only, unused in PvP) ---------- */
function makeEnemyChoices(){
  enemyChoices=[]; const eAlive=allAlive(enemy), pAlive=allAlive(player);
  for (const a of eAlive){
    if (hasStatus(a,'berserk')){
      const everyoneElse=[...pAlive,...eAlive].filter(x=>x!==a);
      const tgt=everyoneElse.length?everyoneElse[(rand()*everyoneElse.length)|0]:null;
      enemyChoices.push({ actor:a, ability:{label:'Berserk Attack',speed:'fast',type:'phys',target:'enemy',
        use:(aa,tt)=>{ if(tt) hit(aa,tt,{},'frenzies at'); } }, target:tgt });
      continue;
    }
    const ta=a.status.find(s=>s.key==='taunt'&&s.dur>0&&s.data?.taunter?.alive());
    if (ta){ const basic=abilitiesFor(a).find(x=>x.isBasic||(x.label&&x.label.toLowerCase()==='attack')); if(basic){
      enemyChoices.push({ actor:a, ability:{label:'Forced Attack',speed:'normal',target:'enemy',
        use:function(aa,tt){ aa._usingAbilityLabel=basic.label; const r=hit(aa,tt,{ability:basic}); aa._usingAbilityLabel=undefined; return r; } }, target:ta.data.taunter });
      continue; } }
    const abil=choice(abilitiesFor(a)); let tgt=null;
    if (abil.target==='enemy') tgt=choice(pAlive); else if (abil.target==='ally') tgt=choice(eAlive); else if (abil.target==='self') tgt=a;
    enemyChoices.push({actor:a,ability:abil,target:tgt});
  }
}

/* ---------- seed helpers ---------- */
function fnv1a(str){ let h=0x811c9dc5>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,0x01000193)>>>0; } return h>>>0; }

function canonicalKey(u){
  // Use network-side + name so it‚Äôs the same on both clients
  const side = u?.side || (u?.team === 'player'
    ? (PVP?.role || 'host')
    : (PVP?.role === 'host' ? 'guest' : 'host'));
  return `${side}|${u?.name || ''}`;
}

/* ---------- canonicalize choices for seeding ---------- */
function canonicalizeChoices(mine, opp){
  const norm=arr=>(arr||[]).map(c=>({a:c.actorName||'', b:c.abilityLabel||'', t:c.targetName||''}));
  const A=norm(mine).map(x=>`M|${x.a}|${x.b}|${x.t}`); const B=norm(opp).map(x=>`O|${x.a}|${x.b}|${x.t}`);
  return A.concat(B).sort().join(';');
}

function rehydrateTarget(stepTarget, allies, foes){
  if (!stepTarget) return null;

  // Already a live unit object?
  if (typeof stepTarget.alive === 'function') return stepTarget;

  const raw =
    (typeof stepTarget === 'string') ? stepTarget :
    String(stepTarget.netId ?? stepTarget.name ?? stepTarget.targetName ?? '');

  if (!raw) return null;

  const pool = [...allies, ...foes];

  // 1) Exact netId match
  let u = pool.find(x => String(x.netId ?? '') === raw);
  if (u) return u;

  // 2) Exact name match
  u = pool.find(x => String(x.name ?? '') === raw);
  if (u) return u;

  // 3) Exact canonicalKey match ("side|name")
  u = pool.find(x => (typeof canonicalKey === 'function') && canonicalKey(x) === raw);
  if (u) return u;

  // 4) If raw is "side|name", also match just the name portion
  if (raw.includes('|')){
    const nameOnly = raw.split('|').slice(1).join('|');
    u = pool.find(x => String(x.name ?? '') === nameOnly);
    if (u) return u;
  }

  return null;
}


/* ---------- resolve (simultaneous) ---------- */
async function resolveSimultaneous(){
  const q=[...playerChoices, ...enemyChoices];

    // unified speed helper (define **once**)
  const effSpeed = (c) =>
    hasStatus(c.actor, 'premonition') ? SPEED_RANK.fast : (SPEED_RANK[c.ability.speed] ?? 1);

  // canonical action order: speed ‚Üí QKN (desc) ‚Üí stable tiebreaker
  q.sort((A, B) => {
    const sa = effSpeed(A), sb = effSpeed(B);
    if (sa !== sb) return sa - sb;

    const qa = JOBS[A.actor.job].QKN, qb = JOBS[B.actor.job].QKN;
    if (qa !== qb) return qb - qa; // higher QKN first

    // final, fully-deterministic tiebreaker across clients
    const ka = canonicalKey(A.actor), kb = canonicalKey(B.actor);
    return ka.localeCompare(kb);
  });


  for (const step of q){
    const { actor } = step;
    if (!actor.alive()){ await sleep(SLEEP_TINY_MS); continue; }

   // berserk at resolve
if (hasStatus(actor,'berserk')){
  const pool = [...player, ...enemy]
    .filter(u => u.alive() && u !== actor)
    .sort((a,b) => String(a.netId || a.name).localeCompare(String(b.netId || b.name)));

  const tgt = pool.length ? pool[(rand() * pool.length) | 0] : null;

  if (tgt){
    const basic = abilitiesFor(actor).find(a => a.isBasic || (a.label && a.label.toLowerCase() === 'attack'));
    if (basic && typeof basic.use === 'function'){
      actor._usingAbilityLabel = basic.label;
      basic.use.call(basic, actor, tgt);
      actor._usingAbilityLabel = undefined;
    } else {
      hit(actor, tgt, {type:(actor.kind==='mag'?'mag':'phys'), scale:1.0 }, 'attacks');
    }
  } else {
    appendLog(`${actor.name} rages in place with no target!`);
  }

  await sleep(ACTION_DELAY_MS);
  continue;
}

    // stun
    if (hasStatus(actor,'stun')){
      if (step.ability && step.ability.speed==='slow') appendLog(`${actor.name}'s ${step.ability.label} is interrupted!`);
      else appendLog(`${actor.name} is stunned and loses their action.`);
      await sleep(ACTION_DELAY_MS); continue;
    }

    // taunt recheck
    const ta=actor.status.find(s=>s.key==='taunt'&&s.dur>0&&s.data?.taunter?.alive());
    if (!ta){ const deadTa=actor.status.find(s=>s.key==='taunt'&&s.dur>0&&!s.data?.taunter?.alive?.()); if(deadTa){ actor.status=actor.status.filter(s=>s!==deadTa); updateStatusView(actor);} }
    else {
      const basic=abilitiesFor(actor).find(x=>x.isBasic||(x.label&&x.label.toLowerCase()==='attack'));
      if (basic && ta.data.taunter.alive()){
        appendLog(`${actor.name} is taunted and must attack ${ta.data.taunter.name}!`);
        actor._usingAbilityLabel=basic.label;
        if (typeof basic.use==='function') basic.use.call(basic,actor,ta.data.taunter); else hit(actor,ta.data.taunter,{ability:basic});
        actor._usingAbilityLabel=undefined; await sleep(ACTION_DELAY_MS); continue;
      }
    }

   // normal exec
let { ability, target } = step;

// Blind whiff gate (unchanged)
if (ability.label==='Attack' && actor.kind==='phys' && hasStatus(actor,'blind') && rand()<0.5){
  appendLog(`${actor.name} is blinded and whiffs!`);
  await sleep(ACTION_DELAY_MS);
  continue;
}

if (ability.label === 'Dispel') {
  console.log('[DBG] Dispel pre-validity', {
    rawStepTarget: step.target,
    rawTargetName:
      (step.target && typeof step.target === 'object')
        ? (step.target.targetName ?? step.target.name ?? step.target.netId ?? null)
        : step.target
  });
}

// ‚úÖ You MUST define these BEFORE rehydrating
const allies = (actor.team === 'player') ? player : enemy;
const foes   = (actor.team === 'player') ? enemy  : player;

// ‚úÖ Rehydrate target (PvP-safe)
target = rehydrateTarget(target, allies, foes);
step.target = target; // optional but useful for debugging

// ‚úÖ Target validity (permit dead ally if ability allows it, e.g. Resurrection)
if (['enemy','ally','any'].includes(ability.target)){
  const allowDead = !!ability.allowDeadTarget;

  if (!target || (!target.alive() && !allowDead)) {
    appendLog(`${actor.name}'s ${ability.label} misses (invalid target).`);
    await sleep(ACTION_DELAY_MS);
    continue;
  }

  if (hasStatus(target, 'invisible')) {
    appendLog(`${actor.name}'s ${ability.label} fails ‚Äî ${target.name} can't be targeted (Invisibility).`);
    await sleep(ACTION_DELAY_MS);
    continue;
  }
}

// Set ‚Äúcurrently using‚Äù labels AFTER target is known
actor._usingAbilityLabel = ability.label;
actor._usingAbilityMeta  = ability;

// Debug probe
if (ability?.label === 'Dispel') {
  console.log('[DBG Dispel resolve]', {
    actor: actor?.name,
    abilityTargetType: ability?.target,
    rawStepTarget: step?.target,
    hydratedTargetName: target?.name,
    hasUseFn: typeof ability?.use === 'function'
  });
}

// ===== Limited-use gate (authoritative) =====
const usesMax = ability?.usesMax | 0;
if (usesMax > 0) {
  const left = getUsesLeft(actor, ability);
  const consumesOn = ability?.usesConsumesOn || 'cast';

  if (left <= 0) {
    appendLog(`${actor.name} tries to use ${ability.label}, but it has no uses left.`);
    await sleep(ACTION_DELAY_MS);
    continue;
  }

  // IMPORTANT: only auto-spend for abilities that do NOT manage spending themselves
  // We'll spend inside the ability for your current 3 (God Tempest, Potion, Resurrection).
  if (consumesOn === 'cast' && !ability.usesSpendInUse) {
    spendUse(actor, ability);
  }
}


const doInvoke = async () => (
  typeof ability.use === 'function'
    ? ability.use.call(
        ability,
        actor,
        ability.target === 'enemy'       ? target :
        ability.target === 'ally'        ? target :
        ability.target === 'any'         ? target :
        ability.target === 'self'        ? actor  :
        ability.target === 'all-enemies' ? foes.filter(u=>u.alive()) :
        ability.target === 'all-allies'  ? allies.filter(u=>u.alive()) :
        null
      )
    : null
);

    if (hasStatus(actor,'arcane_echo') && getAbilityType(actor,ability)==='mag' && !actor._echoing){
      await doInvoke();
      appendLogHTML(`${actor.name}'s <span style="color:#a7c4ff">Arcane Echo</span> repeats ${ability.label}!`);
      actor._echoing=true; actor._echoMult=(CONFIG.ECHO_MULT||1.05);
      await sleep(ACTION_STEP_DELAY_MS);
      await doInvoke();
      actor._echoing=false; actor._echoMult=1; removeStatusKey(actor,'arcane_echo');
    } else { await doInvoke(); }

    if (hasStatus(actor,'blind') && getAbilityType(actor,ability)==='phys' && rand()<0.5){ appendLog(`${actor.name} is blinded and whiffs!`); }

    await sleep(ACTION_DELAY_MS);
  }

    // Extra pause before end-of-round ticks (purely cosmetic)
  await sleep(typeof END_TICK_DELAY_MS === 'number' ? END_TICK_DELAY_MS : vfxMs?.(1000) ?? 1000);

  endRoundTick();

  await sleep(ROUND_END_DELAY_MS);


  const pAlive=player.filter(u=>u.alive()), eAlive=enemy.filter(u=>u.alive());
  if (eAlive.length===0){ appendLog('üèÜ Victory!'); return 'win'; }
  if (pAlive.length===0){ appendLog('üíÄ Defeat.');  return 'lose'; }
  return 'continue';
}

/* ---------- action bar (final) ---------- */
function renderActionBarForCurrent(){
  // If I'm waiting for opponent in PvP, show a small waiting stub instead of inputs
  if (PVP && PVP.phase === 'battle' && PVP.waitingForOpp) {
    actionButtonsEl.innerHTML = '';
    actionPromptEl.textContent = `Round ${roundNumber} ‚Äî Waiting for opponent‚Ä¶`;
    const stub = document.createElement('div');
    stub.style.cssText = 'opacity:.85;font-size:18px;text-align:center;padding:8px;';
    stub.textContent = 'Choices submitted. Waiting for the other side...';
    actionButtonsEl.appendChild(stub);
    return;
  }

  if (!actionButtonsEl || !actionPromptEl) initActionBarShell();
  actionButtonsEl.innerHTML = '';

  const actor = currentActor();
  if (!actor){ actionPromptEl.textContent=''; return; }
  actionPromptEl.textContent = `Choose action for ${actor.name}`;

  // ---- local helper: label with uses ----
  const labelWithUses = (ab) => {
    const max = ab?.usesMax | 0;
    if (!max) return ab?.label || '';
    const left = (typeof getUsesLeft === 'function') ? getUsesLeft(actor, ab) : null;
    // If helpers aren't present, fall back to just label
    if (left == null) return ab.label;
    return `${ab.label} (${left}/${max})`;
  };

  const isOutOfUses = (ab) => {
    const max = ab?.usesMax | 0;
    if (!max) return false;
    const left = (typeof getUsesLeft === 'function') ? getUsesLeft(actor, ab) : max;
    return (left | 0) <= 0;
  };

  const makeButton = (ability) => {
    const btn = document.createElement('button');
    btn.className = 'action-btn';

    const s = ability.speed || 'normal';
    const on = { fast:3, normal:2, slow:1 }[s] ?? 2;

    const disabled = isOutOfUses(ability);
    if (disabled) {
      btn.disabled = true;
      btn.classList.add('disabled');
      btn.title = 'No uses left';
    }

    btn.innerHTML = `
      <div class="btn-inner">
        <div class="text">
          <div class="label">${labelWithUses(ability)}</div>
          <div class="desc">${ability.desc || ''}</div>
        </div>
        <div class="speed ${s}" title="${s}">
          <span class="dot ${on >= 1 ? '' : 'off'}"></span>
          <span class="dot ${on >= 2 ? '' : 'off'}"></span>
          <span class="dot ${on >= 3 ? '' : 'off'}"></span>
        </div>
      </div>
    `;

    btn.onclick = () => {
      // UX-only guard (authoritative spending should still be in resolveSimultaneous)
      if (isOutOfUses(ability)) {
        appendLog?.(`${actor.name} has no uses left for ${ability.label}.`);
        return;
      }

      _pendingAbility = ability;

      if (ability.target === 'enemy' || ability.target === 'ally' || ability.target === 'any') {
        _pendingTargetPick = true;
        _pendingAbilityTarget = ability.target;
      } else {
        _pendingTargetPick = false;
        _pendingAbilityTarget = null;
        confirmChoice(null);
      }

      updateTopBarForCurrentSelection();
    };

    return btn;
  };

  // Real placeholder button factory (no "..." anywhere)
  const makePlaceholder = () => {
    const ph = document.createElement('button');
    ph.className = 'action-btn placeholder';
    ph.disabled = true;
    ph.innerHTML = `
      <div class="btn-inner">
        <div class="text">
          <div class="label">Empty</div>
          <div class="desc"></div>
        </div>
      </div>
    `;
    return ph;
  };

  const raw = abilitiesFor(actor) || [];
  const isAttack = a => a && (a.isBasic || (a.label && a.label.toLowerCase()==='attack'));

  const attack = raw.find(isAttack);
  const others = raw.filter(a => !isAttack(a));

  const rank = { fast:0, normal:1, slow:2 };
  others.sort((a,b) =>
    (rank[a.speed] ?? 1) - (rank[b.speed] ?? 1) ||
    (a.label || '').localeCompare(b.label || '')
  );

  const picks = [];
  if (attack) picks.push(attack);
  for (const ab of others){
    if (picks.length >= 6) break;
    picks.push(ab);
  }

  for (let i=0; i<6; i++){
    const node = picks[i] ? makeButton(picks[i]) : makePlaceholder();
    actionButtonsEl.appendChild(node);
  }
}

async function confirmChoice(target){
  const actor = currentActor(); 
  if (!actor) return;

  if (!actor.alive()){
    appendLog(`${actor.name} is defeated and cannot act.`);
    _pendingTargetPick = false;
    _pendingAbilityTarget = null;
    _pendingAbility = null;

    const alive = player.filter(u=>u.alive());
    selectingIndex = Math.min(selectingIndex + 1, alive.length);
    updateTopBarForCurrentSelection(); 
    renderActionBarForCurrent(); 
    return;
  }

  if (!_pendingAbility){
    appendLog('Choose an ability first.');
    return;
  }

  /* =========================
     TARGET VALIDITY (FIX HERE)
     ========================= */
  if (['enemy','ally','any'].includes(_pendingAbility.target)) {
    const ab = _pendingAbility;
    const allowDead = !!ab.allowDeadTarget;

    // If you got here, this ability expects a target object
    if (!target){
      appendLog('No valid target.');
      _pendingTargetPick = true;
      updateTopBarForCurrentSelection();
      return;
    }

    // Invisibility blocks ALL direct targeting (enemy/ally/any)
    if (hasStatus(target,'invisible')){
      appendLog(`${target.name} is invisible and can't be targeted.`);
      vfxFloatText?.(target, 'INVISIBLE', {
        ms: (typeof vfxMs==='function' ? vfxMs(1250) : 1250),
        fontSize: Math.floor((typeof vfxScale==='function' ? vfxScale(14) : 14)),
        color: '#bdbdff'
      });
      return;
    }

    // OPTIONAL: Shift blocks PHYSICAL direct-target abilities
    if (hasStatus(target,'shift') && ab.type === 'phys'){
      appendLog(`${target.name} is Shifted and can't be targeted by physical attacks.`);
      vfxFloatText?.(target, 'SHIFT', {
        ms: (typeof vfxMs==='function' ? vfxMs(1000) : 1000),
        fontSize: Math.floor((typeof vfxScale==='function' ? vfxScale(14) : 14)),
        color: '#a7c4ff'
      });
      return;
    }

    // Dead target rules
    if (!target.alive?.() && !allowDead){
      appendLog('No valid target.');
      _pendingTargetPick = true;
      updateTopBarForCurrentSelection();
      return;
    }
  }
  /* ======== END FIX ======== */

  const ta = actor.status.find(s=>s.key==='taunt'&&s.dur>0&&s.data?.taunter?.alive?.());
  if (ta){
    const isBasic = a=>a&&(a.isBasic||(a.label&&a.label.toLowerCase()==='attack'));
    const basic = abilitiesFor(actor).find(isBasic);
    if (basic && ta.data.taunter.alive()){
      appendLog(`${actor.name} is taunted and must attack ${ta.data.taunter.name}!`);
      _pendingAbility = basic;
      _pendingTargetPick = false;
      _pendingAbilityTarget = null;
      target = ta.data.taunter;
    }
  }

  const ability = _pendingAbility;
  _pendingAbility = null;

  if (ability?.label === 'Dispel') {
    console.log('[DBG] queued Dispel', {
      actor: actor?.name,
      target: target?.name,
      targetAlive: !!target?.alive?.(),
      pendingTargetPick: _pendingTargetPick,
      pendingAbilityTarget: _pendingAbilityTarget
    });
  }

  playerChoices.push({
  actor,
  ability,
  // store the actual unit object locally; wire conversion happens in choiceToWire()
  target: target || null
});

  const alive = player.filter(u=>u.alive());
  selectingIndex++;

  _pendingTargetPick = false;
  _pendingAbilityTarget = null;
  _pendingAbility = null;

  if (selectingIndex >= alive.length){
    sendMyRoundChoices();
    if (Array.isArray(PVP.roundBuf.opp[roundNumber])){ 
      tryResolveRoundWithBothSides(roundNumber); 
    }
    if (typeof showRightWaitHint==='function') showRightWaitHint();
    if (topLeftEl) topLeftEl.textContent = `Round ${roundNumber} ‚Äî Waiting for opponent‚Ä¶`;
    return;
  }

  updateTopBarForCurrentSelection(); 
  renderActionBarForCurrent();
}


/* ---------- Phaser Scene ---------- */
let game = null;
let sceneRef = null;

class GameScene extends Phaser.Scene{
  constructor(){ super('Game'); }

  preload(){
    const bgUrl = (window.ARENA_BG_URL && window.ARENA_BG_URL.trim()) ? window.ARENA_BG_URL.trim() : '';
    if (bgUrl){
      this.load.setCORS('anonymous');
      this.load.image('arena_bg', bgUrl);
    }
    const base = (window.SPRITE_BASE_URL || 'https://raw.githubusercontent.com/krezt/tol-assets/main').replace(/\/+$/,'');
    if (base){
      this.load.setCORS('anonymous');
      const JOB_LIST = (Array.isArray(ALL_CLASSES) && ALL_CLASSES.length) ? ALL_CLASSES :
        ['Warrior','Barbarian','Rogue','Cleric','Mage','Paladin','Archer','Monk','Necromancer','Mystic'];
      for (const job of JOB_LIST){
  // Battlefield portraits (used in unit panels)
  this.load.image(`portrait_${job}`, `${base}/portraits/${encodeURIComponent(job)}.png`);

  // Draft portraits (used in draft UI)
  this.load.image(`draft_${job}`, `${base}/draft_portraits/${encodeURIComponent(job)}.png`);
}
      const STATUS_KEYS = [
  'poison','bleed',
  'stun','taunt','blind','berserk',
  'def_down','def_up','atk_up','sdm_up',
  'guard','marked','premonition','arcane_echo',
  'divine_shield','shield_redirect','counter',
  'invisible','shift','shinobi_haste'
];

      for (const k of STATUS_KEYS){
        this.load.image(`status_${k}`, `${base}/status/${k}.png`);
      }
    }
  }

  create(){
    sceneRef = this;

    // layout constants
    this.PANEL_W = 380; this.PANEL_H = 120; this.PAD_X = 10; this.PAD_Y = 6;
    this.HPBAR_W = this.PANEL_W - (this.PAD_X*2) - 70;
    this.MARGIN_L = 20; this.MARGIN_R = 20; this.GAP_MIN = 48;
    this.Y_START = 80; this.ROW_H = this.PANEL_H + 8;

    // background (top-anchored, resizes with battlefield without cropping top)
this.bgMode = 'TOP_CONTAIN'; // change to 'TOP_COVER' if you prefer filling the whole canvas

if (this.textures.exists('arena_bg')) {
  this.bgImage = this.add.image(0, 0, 'arena_bg')
    .setOrigin(0.5, 0)       // ‚úÖ top-center anchor
    .setScrollFactor(0)
    .setDepth(-120);

  this.updateBackgroundLayout(); // ‚úÖ initial layout
} else {
  this.bgSolid = this.add.rectangle(0, 0, this.scale.width, this.scale.height, 0x0f0f13, 1)
    .setOrigin(0, 0)
    .setScrollFactor(0)
    .setDepth(-120);
}

    // headers
    this.nameStyle = { fontSize:'18px', fontStyle:'bold', color:'#ffffff' };
    this.titleTxt  = this.add.text(20,20,'ROS: Tournament of Legends',{fontSize:'24px', fontStyle:'bold'});
    this.playerHdr = this.add.text(0,54,(PVP.playerName||'You'),      {fontSize:'18px', fontStyle:'bold', color:'#ffffff'});
    this.enemyHdr  = this.add.text(0,54,(PVP.opponentName||'Opponent'),{fontSize:'18px', fontStyle:'bold', color:'#ffffff'});
    const headerAlpha = 0.80;
    this.playerHdrBg = this.add.rectangle(0,0,10,10,0x000000, headerAlpha).setOrigin(0,0).setDepth(-1);
    this.enemyHdrBg  = this.add.rectangle(0,0,10,10,0x000000, headerAlpha).setOrigin(0,0).setDepth(-1);

    // live header name updater
    this.updateHeaderNames = () => {
      const mine = PVP?.myName || 'You';
      const opp  = PVP?.opponentName || 'Opponent';
      this.playerHdr.setText(mine);
      this.enemyHdr.setText(opp);
    };
    this.updateHeaderNames();

    // columns/containers
    this.playerCol = this.add.container(0,0);
    this.enemyCol  = this.add.container(0,0);
    this._enemyRowClickers = [];
    this._allyRowClickers  = [];

    // 1) hydrate units from picks when scene starts (covers post-restart race)
    if ((!Array.isArray(player) || player.length === 0) && Array.isArray(PVP?.picksMe) && PVP.picksMe.length){
      player = PVP.picksMe.map(job => makeUnit(job, 'player'));
    }
    if ((!Array.isArray(enemy) || enemy.length === 0) && Array.isArray(PVP?.picksOpp) && PVP.picksOpp.length){
      enemy = PVP.picksOpp.map(job => makeUnit(job, 'enemy'));
    }
ensureUnitSides();

    // DBG: log counts so you can see what the scene sees
    appendLog(`[DBG] Scene.create ‚Äî player=${player.length}, enemy=${enemy.length}, picksMe=${PVP?.picksMe?.length||0}, picksOpp=${PVP?.picksOpp?.length||0}`);

    const texExists = (k) => this.textures.exists(k);

    // ---------- draw a single unit panel ----------
    const drawPanel = (parent, u, colX, topY, isEnemy) => {
      const panel = this.add.container(colX, topY); parent.add(panel);
      const bg = this.add.rectangle(0,0,this.PANEL_W,this.PANEL_H,0x1c1f26,0.55).setOrigin(0,0);
      const bd = this.add.rectangle(0,0,this.PANEL_W,this.PANEL_H).setOrigin(0,0).setStrokeStyle(1,0x3b4252,1);
      panel.add([bg,bd]);

      const x = this.PAD_X, y = this.PAD_Y;

      const portraitKey = `portrait_${u.job}`;
      let nameOffset = 0; let hpBarX = x, hpBarW = this.HPBAR_W;
      if (texExists(portraitKey)){
        const pImg = this.add.image(x,y,portraitKey).setOrigin(0,0);
        pImg.setDisplaySize(48,48);
        panel.add(pImg);
        nameOffset = 48 + 8; hpBarX = x + nameOffset;
        hpBarW = Math.max(80, this.PANEL_W - (this.PAD_X*2) - 70 - nameOffset);
      }

      const name = this.add.text(x+nameOffset, y, u.name, this.nameStyle);
      const hpTxt= this.add.text(this.PANEL_W-this.PAD_X, y, `HP ${u.hp}/${u.maxHP}`,
                      {fontSize:'18px', fontStyle:'bold', color:'#dfe7ff'}).setOrigin(1,0);
      panel.add([name,hpTxt]);

      const hpBarY = y+26;
      const hpBg = this.add.rectangle(hpBarX, hpBarY, hpBarW, 12, 0x2b2f3a).setOrigin(0,0.5);
      const fg   = this.add.rectangle(hpBarX, hpBarY, hpBarW, 12, 0x47d16a).setOrigin(0,0.5);
      panel.add([hpBg, fg]);

      const statsTxt = this.add.text(x+nameOffset, hpBarY+18, '', {fontSize:'14px', color:'#dfe7ff'});
panel.add(statsTxt);

const statsMaxW = (this.PANEL_W - this.PAD_X) - (x + nameOffset);

const statusNodes = [];
u._ui = {
  panel, fg, txt:hpTxt, statusNodes, statsTxt, baseX:x, baseY:y, scene:this,
  nameOffset, hpBarWidth:hpBarW,
  statsMaxW,

  badgeStartX: x + nameOffset,
  badgeY: statsTxt.y + 16,
  badgeMaxW: Math.max(80, this.PANEL_W - (this.PAD_X*2) - nameOffset)
};

// refresh visuals (THIS MUST BE OUTSIDE THE OBJECT LITERAL)
u._refresh = () => {
  const p = u.hp / u.maxHP;
  u._ui.fg.width = Math.max(1, Math.floor(u._ui.hpBarWidth * Math.max(0, p)));
  u._ui.fg.fillColor = p > 0.5 ? 0x47d16a : (p > 0.25 ? 0xffc857 : 0xff5d6c);
  u._ui.txt.setPosition(this.PANEL_W - this.PAD_X, u._ui.baseY);
  u._ui.txt.setText(`HP ${Math.max(0, u.hp)}/${u.maxHP}`);

  const isDead = u.hp <= 0;
  u._ui.panel.setAlpha(isDead ? 0.55 : 1);

  // KO cross overlay
  if (isDead) {
    if (!u._ui._deadCross) {
      const g = this.add.graphics();
      g.lineStyle(2, 0xff6b6b, 0.95);
      const pad = 6, w = this.PANEL_W, h = this.PANEL_H;
      g.strokeLineShape(new Phaser.Geom.Line(pad, pad, w - pad, h - pad));
      g.strokeLineShape(new Phaser.Geom.Line(w - pad, pad, pad, h - pad));
      u._ui.panel.add(g);
      u._ui._deadCross = g;
    }
  } else {
    if (u._ui._deadCross) { u._ui._deadCross.destroy(); u._ui._deadCross = null; }
  }

  if (!isDead && u._ui._struck) { u._ui._struck.destroy(); u._ui._struck = null; }

  updateStatusView(u);
};

u._refresh();

      // click to target
      const hitBox = this.add.rectangle(this.PANEL_W/2, 24, this.PANEL_W, 48, 0x000000, 0)
                        .setInteractive({useHandCursor:true});
      panel.add(hitBox);
      hitBox.on('pointerover', ()=>{ name.setStyle({color:'#a7c4ff', fontStyle:'bold'}); });
      hitBox.on('pointerout',  ()=>{ name.setStyle({color:'#ffffff', fontStyle:'bold'}); });
      hitBox.on('pointerdown', ()=>{
  if (!(_pendingTargetPick && _pendingAbility)) return;

  const ab = _pendingAbility;
  const want = _pendingAbilityTarget; // 'enemy' | 'ally' | 'any'

  const isAlly = !isEnemy;
  const ok =
    (want === 'any') ||
    (want === 'enemy' && isEnemy) ||
    (want === 'ally'  && isAlly);

  if (!ok){
    appendLog(`That target is not valid for ${ab.label}.`);
    return;
  }

  // Invisibility blocks direct targeting (any direct target)
  if (hasStatus(u,'invisible')){
    appendLog(`${u.name} is invisible and can't be targeted.`);
    vfxFloatText?.(u, 'INVISIBLE', {
      ms: (typeof vfxMs==='function'? vfxMs(1250):1250),
      fontSize: Math.floor((typeof vfxScale==='function'? vfxScale(14):14)),
      color: '#bdbdff'
    });
    return;
  }

  // OPTIONAL: Shift blocks *physical* direct-target abilities
  if (hasStatus(u,'shift') && (ab.type === 'phys')){
    appendLog(`${u.name} is Shifted and can't be targeted by physical attacks.`);
    vfxFloatText?.(u, 'SHIFT', {
      ms: (typeof vfxMs==='function'? vfxMs(1000):1000),
      fontSize: Math.floor((typeof vfxScale==='function'? vfxScale(14):14)),
      color: '#a7c4ff'
    });
    return;
  }

  // ‚úÖ valid target, proceed
  confirmChoice(u);
});

      if (isEnemy) this._enemyRowClickers.push({rect:hitBox,label:name});
      else         this._allyRowClickers.push({rect:hitBox,label:name});
    }; // end drawPanel

    // ---------- SINGLE rebuild helper ----------
    this.rebuildPanels = () => {
      this.playerCol.removeAll(true);
      this.enemyCol.removeAll(true);
      this._enemyRowClickers = [];
      this._allyRowClickers  = [];

      for (let i = 0; i < player.length; i++) {
        drawPanel(this.playerCol, player[i], 0, this.Y_START + i * this.ROW_H, false);
      }
      for (let i = 0; i < enemy.length; i++) {
        drawPanel(this.enemyCol,  enemy[i],  0, this.Y_START + i * this.ROW_H, true);
      }

      for (const u of [...player, ...enemy]) { if (u && u._refresh) u._refresh(); }

      this.reflow();
    };

    // 2) initial render now that helper exists
    this.rebuildPanels();

    // 3) last-ditch fallback: if still empty, force hydrate & redraw
    if ((player.length === 0 || enemy.length === 0) &&
        (Array.isArray(PVP?.picksMe) && PVP.picksMe.length) &&
        (Array.isArray(PVP?.picksOpp) && PVP.picksOpp.length)) {
      appendLog('[DBG] Forcing hydrate from picks after restart‚Ä¶');
      player = PVP.picksMe.map(job => makeUnit(job, 'player'));
      enemy  = PVP.picksOpp.map(job => makeUnit(job, 'enemy'));
      this.rebuildPanels();
    }

    // layout, resize
    this.reflow();
    this.scale.on('resize', ()=> this.reflow());

// round UI + action bar ONLY in battle
if (PVP.phase === 'battle') {
  roundNumber = 1;
  resetRoundState();
  updateTopBarForCurrentSelection();
  renderActionBarForCurrent();
} else {
  // lobby/idle: clear battle UI
  clearCombatUI();
  setTopBarLobby();
}

}

updateBackgroundLayout(){
  const W = this.scale.width, H = this.scale.height;

  // --- Background sizing/positioning ---
  if (this.bgImage && this.textures.exists('arena_bg')) {
    const texImg = this.textures.get('arena_bg').getSourceImage();
    const iw = texImg?.width  || this.bgImage.width  || 1;
    const ih = texImg?.height || this.bgImage.height || 1;

    // ‚úÖ Scale to COVER the battlefield (no empty bars),
    // but anchor TOP so the top never gets cut off.
    const s = Math.max(W / iw, H / ih);

    this.bgImage
      .setScale(s)
      .setOrigin(0.5, 0)     // top-centered anchor
      .setPosition(W / 2, 0);

  } else if (this.bgSolid) {
    // solid fallback fits the canvas
    this.bgSolid.setPosition(0, 0);
    this.bgSolid.width  = W;
    this.bgSolid.height = H;
  }

  // --- Header background pads (unchanged logic) ---
  const padX = 8, padY = 3;

  if (this.playerHdrBg && this.playerHdr) {
    this.playerHdrBg.setPosition(this.playerHdr.x - padX, this.playerHdr.y - padY);
    this.playerHdrBg.width  = this.playerHdr.width  + padX * 2;
    this.playerHdrBg.height = this.playerHdr.height + padY * 2;
  }

  if (this.enemyHdrBg && this.enemyHdr) {
    this.enemyHdrBg.setPosition(this.enemyHdr.x - padX, this.enemyHdr.y - padY);
    this.enemyHdrBg.width  = this.enemyHdr.width  + padX * 2;
    this.enemyHdrBg.height = this.enemyHdr.height + padY * 2;
  }
}
reflow(){
  const W = this.scale.width;
  const usable = Math.max(640, W);

  this.PANEL_W = (usable < 1000) ? 340 : 380;
  this.HPBAR_W = this.PANEL_W - (this.PAD_X*2) - 70;

  // Update per-unit cached widths (if panels already exist)
  for (const u of [...(globalThis.player||[]), ...(globalThis.enemy||[])]) {
    if (!u || !u._ui) continue;
    const localHPW = this.PANEL_W - (this.PAD_X*2) - 70 - (u._ui.nameOffset || 0);
    u._ui.hpBarWidth = Math.max(80, localHPW);
  }

  const LEFT_X  = this.MARGIN_L;
  const RIGHT_X = Math.max(
    LEFT_X + this.PANEL_W + this.GAP_MIN,
    usable - (this.PANEL_W + this.MARGIN_R)
  );

  if (this.playerHdr) this.playerHdr.setPosition(LEFT_X, 54);
  if (this.enemyHdr)  this.enemyHdr.setPosition(RIGHT_X, 54);

  if (this.playerCol) this.playerCol.setPosition(LEFT_X, 0);
  if (this.enemyCol)  this.enemyCol.setPosition(RIGHT_X, 0);

  if (typeof this.updateHeaderNames === 'function') this.updateHeaderNames();

  // Refresh visuals after resize
  for (const u of [...(globalThis.player||[]), ...(globalThis.enemy||[])]) {
    if (u && typeof u._refresh === 'function') u._refresh();
  }

  this.updateBackgroundLayout?.();
}

}


/* ===== Lobby overlay in battlefield (DOM, not Phaser) ===== */
function unmountLobbyInField(){
  const ov = document.getElementById('lobby-overlay');
  if (ov) ov.remove();
}

function mountLobbyInField(){
  unmountLobbyInField();
  const root = document.getElementById('battlefield');
if (!root) { console.error('[Lobby] #battlefield not found ‚Äî cannot mount lobby'); return; }
  if (!root) return;
  root.style.position = 'relative';

  const ov = document.createElement('div');
  ov.id = 'lobby-overlay';
  Object.assign(ov.style, {
    position:'absolute', inset:'8px',
    background:'rgba(10,12,16,0.92)', border:'2px solid #3a4257', borderRadius:'8px',
    color:'#e8e8f0', zIndex: 5, display:'flex', flexDirection:'column', gap:'10px', padding:'12px'
  });

  // Header + name
  const header = el('div', { style:{ display:'flex', alignItems:'center', justifyContent:'space-between', gap:'8px' }});
  header.appendChild(el('div', { style:{ fontWeight:'800', fontSize:'20px' }}, 'PvP Lobby'));
  const nameWrap = el('div', { style:{ display:'flex', gap:'6px', alignItems:'center' }});
  nameWrap.appendChild(el('label', { style:{ fontSize:'12px', opacity:.9 }}, 'Your name:'));
  const nameInput = el('input', { id:'lobby-name', placeholder:'Type your name', value:(PVP.myName||PVP.playerName||'') });
  Object.assign(nameInput.style, { background:'#22314b', color:'#fff', border:'1px solid #4a5a7a', borderRadius:'4px', padding:'6px 8px', minWidth:'160px' });
  const saveBtn = el('button', { class:'action-btn', style:{ padding:'6px 10px' }}, el('div', { class:'label', style:{ fontSize:'14px' }}, 'Save'));
  header.appendChild(nameWrap);
  nameWrap.appendChild(nameInput); nameWrap.appendChild(saveBtn);
  ov.appendChild(header);

  // Tip + error
  const tip  = el('div', { id:'lobby-tip',  style:{ fontSize:'12px', opacity:.85, textAlign:'center' }}, 'Tip: share the room ID so friends can join.');
  const err  = el('div', { id:'lobby-error',style:{ fontSize:'12px', color:'#ffb3b3', textAlign:'center', display:'none' }}, '');
  ov.appendChild(tip); ov.appendChild(err);

  // Controls: Create room, Quick Match, Join by ID
  const controls = el('div', { style:{ display:'flex', gap:'8px', flexWrap:'wrap', justifyContent:'center' }});
  const mkBtn = (label, onClick) => {
    const b = el('button', { class:'action-btn', style:{ padding:'8px 12px' }}, el('div', { class:'label', style:{ fontSize:'16px' }}, label));
    b.onclick = onClick; return b;
  };
  const createBtn = mkBtn('Create Room', async ()=>{ await connectWS(); send({ kind:'create_room' }); });
  const quickBtn  = mkBtn('Quick Match', async ()=>{ await connectWS(); send({ kind:'queue' }); });
  controls.appendChild(createBtn); controls.appendChild(quickBtn);

  // Join by ID
  const joinWrap = el('div', { style:{ display:'flex', gap:'6px', alignItems:'center', justifyContent:'center' }});
  const joinInp  = el('input', { id:'lobby-join-id', placeholder:'Enter room ID' });
  Object.assign(joinInp.style, { background:'#22314b', color:'#fff', border:'1px solid #4a5a7a', borderRadius:'4px', padding:'6px 8px', minWidth:'140px' });
  const joinBtn  = mkBtn('Join', async ()=>{ const id=(joinInp.value||'').trim(); if(!id) return; await connectWS(); send({ kind:'join_room', id }); });
  joinWrap.appendChild(joinInp); joinWrap.appendChild(joinBtn);

  ov.appendChild(controls);
  ov.appendChild(joinWrap);

  // Status after create
  const roomStatus = el('div', { id:'lobby-room-status', style:{ display:'none', textAlign:'center', fontSize:'13px' }});
  ov.appendChild(roomStatus);

  // List
  const list = el('div', { id:'lobby-rooms', style:{ marginTop:'6px', overflow:'auto', flex:'1 1 auto', borderTop:'1px solid #3a4257', paddingTop:'8px' }});
  ov.appendChild(list);

  root.appendChild(ov);
enterLobbyUI();

  // Update the top bar while in lobby
  setTopBarLobby();


  // Save name handlers
  const saveName = () => {
    const v = (nameInput.value || '').trim().slice(0,16);
    if (!v) return;
    PVP.myName = v; PVP.playerName = v;
    connectWS().then(()=> send({ kind:'set_name', name:v }));
    if (sceneRef && sceneRef.updateHeaderNames) sceneRef.updateHeaderNames();
  };
  saveBtn.onclick = saveName;
  nameInput.addEventListener('keydown', e => { if (e.key==='Enter') { e.preventDefault(); saveName(); }});
  nameInput.addEventListener('blur', saveName);

  // Ask for rooms + periodic refresh
  connectWS().then(()=>{
    send({ kind:'list_rooms' });
    const errTimer = setTimeout(()=>{
      const e = document.getElementById('lobby-error');
      const ls= document.getElementById('lobby-rooms');
      if (e && ls && !ls.dataset.populated){
        e.textContent = 'No response from server. Lobby features may not be enabled on this server.';
        e.style.display = 'block';
      }
    }, 2000);
    PVP._roomsInterval && clearInterval(PVP._roomsInterval);
    PVP._roomsInterval = setInterval(()=> send({ kind:'list_rooms' }), 2500);
  });
}

function refreshLobbyList(rooms){
  const list = document.getElementById('lobby-rooms');
  const err  = document.getElementById('lobby-error');
  if (!list) return;
  list.textContent = '';
  list.dataset.populated = '1';
  if (err) err.style.display = 'none';

  if (!rooms || rooms.length === 0){
    const empty = el('div', { style:{ opacity:.8, fontSize:'13px', textAlign:'center', padding:'8px' }}, 'No rooms yet. Create one!');
    list.appendChild(empty);
    return;
  }
  for (const r of rooms){
    // server returns {id, name, players}
    const row  = el('div', { style:{ display:'flex', alignItems:'center', justifyContent:'space-between', border:'1px solid #3a4257', background:'#1b2130', borderRadius:'6px', padding:'8px', marginBottom:'6px' }});
    const info = el('div', {}, `${r.id} ‚Äî ${r.name || 'Room'} (${r.players || 1}/2)`);
    const jBtn = el('button', { class:'action-btn', style:{ padding:'6px 10px' }}, el('div', { class:'label', style:{ fontSize:'14px' }}, 'Join'));
    jBtn.onclick = async ()=>{ await connectWS(); send({ kind:'join_room', id: r.id }); };
    row.appendChild(info); row.appendChild(jBtn);
    list.appendChild(row);
  }
}

function showLobbyError(msg){
  const e = document.getElementById('lobby-error');
  if (e){ e.textContent = msg; e.style.display = 'block'; }
}

function setLobbyRoomStatus(id){
  const n = document.getElementById('lobby-room-status');
  if (!n) return;
  if (id){
    n.style.display = 'block';
    n.textContent = `Room ${id} created. Waiting for opponent‚Ä¶  (Share this ID to invite friends)`;
  } else {
    n.style.display = 'none';
    n.textContent = '';
  }
}


/* ---------- Phaser boot ---------- */
/* ---------- Phaser boot ---------- */
function sizeFromBattlefield(){
  const r = bfEl.getBoundingClientRect();
  const w = Math.max(640, Math.floor(r.width));
  const h = Math.max(480, Math.floor(r.height));
  return { w, h };
}
function bootPhaser(){
  const s = sizeFromBattlefield();
  game = new Phaser.Game({
    type: Phaser.AUTO,
    parent: 'battlefield',
    width: s.w,
    height: s.h,
    backgroundColor: '#14141b',
    scene: [GameScene],
    pixelArt: true
  });
  globalThis.gameRef = game;
}
function resizePhaserToBattlefield(){
  if (!game || !game.scale) return;
  const s = sizeFromBattlefield();
  if (Number.isFinite(s.w) && Number.isFinite(s.h) && s.w > 0 && s.h > 0){
    game.scale.resize(s.w, s.h);
  }
}

/* ---------- One-time boot ---------- */
window.addEventListener('load', () => {
  window.SPRITE_BASE_URL   = window.SPRITE_BASE_URL || 'https://raw.githubusercontent.com/krezt/tol-assets/main';
  window.ARENA_BG_URL      = window.ARENA_BG_URL    || 'https://raw.githubusercontent.com/krezt/tol-assets/refs/heads/main/bg/arena_bg6.png';
  window.ACTION_RIGHT_URL  = window.ACTION_RIGHT_URL || 'https://raw.githubusercontent.com/krezt/tol-assets/main/ui/right_panel.png';

  // 1) Build action bar DOM
  initActionBarShell();

  // 2) Show right panel image
  setStaticRightPanelImage(window.ACTION_RIGHT_URL);

  // 3) Boot Phaser
  bootPhaser();
  setTimeout(resizePhaserToBattlefield, 0);

  // 4) Mount lobby if needed
  if (window.PVP && (PVP.phase === 'idle' || !PVP.phase)) {
    PVP.phase = 'idle';
    setTimeout(() => { if (typeof showLobby === 'function') showLobby(); }, 0);
  }

  // 5) Resize observer for battlefield + background layout
  if ('ResizeObserver' in window){
    const ro = new ResizeObserver(() => {
      resizePhaserToBattlefield();
      if (sceneRef && sceneRef.updateBackgroundLayout) sceneRef.updateBackgroundLayout();
    });
    ro.observe(bfEl);
  }
});

// normal window resize
window.addEventListener('resize', resizePhaserToBattlefield);


/* ---------- PvP bootstrap ---------- */
(function bootstrapPVP(){
  const P=(window.PVP=window.PVP||{});
  P.roundBuf = P.roundBuf || { mine:{}, opp:{}, host:{}, guest:{} };
  P.enabled  = P.enabled ?? false;
  P.ws       = P.ws ?? null;
  P.url      = P.url ?? (window.PVP_WS_URL||'ws://localhost:8080');
  P.meId     = P.meId ?? null;
  P.matchId  = P.matchId ?? null;
  P.roomId   = P.roomId ?? null;
  P.role     = P.role ?? null;                 // 'host' | 'guest'
  P.phase    = P.phase ?? 'idle';              // 'idle' | 'draft' | 'battle'
  P.pool     = P.pool ?? [...ALL_CLASSES];
  P.picksMe  = P.picksMe ?? [];
  P.picksOpp = P.picksOpp ?? [];
  P.pickTurn = P.pickTurn ?? 'me';
  P.pickCount= P.pickCount ?? 0;
  P.sentForRound = null;
  P.playerName = P.playerName || 'You';
  P.opponentName = P.opponentName || 'Opponent';
  P.myName = P.myName || 'You';
})();

const DRAFT_ORDER = ['host','guest','guest','host','guest','host']; // A‚ÄìB‚ÄìB‚ÄìA‚ÄìB‚ÄìA

function ensureRoundBuf(){
  PVP.roundBuf = PVP.roundBuf || { mine:{}, opp:{}, host:{}, guest:{} };
  PVP.roundBuf.mine  ||= {};
  PVP.roundBuf.opp   ||= {};
  PVP.roundBuf.host  ||= {};
  PVP.roundBuf.guest ||= {};
}
ensureRoundBuf();

/* ---------- light DOM helper (scoped) ---------- */
function el(tag, attrs = {}, ...kids){
  const n=document.createElement(tag);
  for (const [k,v] of Object.entries(attrs||{})){
    if (k==='class') n.className=v;
    else if (k==='style' && v && typeof v==='object') Object.assign(n.style,v);
    else n.setAttribute(k,v);
  }
  for (const kid of kids){ if (kid==null) continue; n.appendChild(typeof kid==='string'?document.createTextNode(kid):kid); }
  return n;
}

/* ---------- send + connect ---------- */
function send(msg){
  if (PVP.ws && PVP.ws.readyState === WebSocket.OPEN){
    PVP.ws.send(JSON.stringify(msg));
  } else {
    (PVP._outbox ||= []).push(msg);
    console.warn('[PvP] queued (socket not open):', msg.kind);
  }
}

let _wsOpenPromise = null;

function connectWS(){
  if (PVP.ws && (PVP.ws.readyState === WebSocket.OPEN || PVP.ws.readyState === WebSocket.CONNECTING)){
    return _wsOpenPromise || Promise.resolve();
  }

  _wsOpenPromise = new Promise((resolve)=>{

    const roomId = PVP.roomId || 'lobby';
    const RELAY_ORIGIN = 'wss://ros-relay.onrender.com/ws';
    const RELAY_URL = RELAY_ORIGIN + '?room=' + encodeURIComponent(roomId);

    const ws = new WebSocket(RELAY_URL);
    PVP.ws = ws;

    ws.addEventListener('open', ()=>{
      appendLog('[PvP] Connected to matchmaking.');
      ws.send(JSON.stringify({ kind:'hello', build:'ros-pvp-v1' }));

      if (PVP.myName) ws.send(JSON.stringify({ kind:'set_name', name:PVP.myName }));

      if (PVP.phase === 'idle') {
        mountLobbyInField();
        ws.send(JSON.stringify({ kind:'list_rooms' }));
      }

      if (Array.isArray(PVP._outbox)){
        for (const m of PVP._outbox) ws.send(JSON.stringify(m));
        PVP._outbox.length = 0;
      }

      if (PVP._wantQueue) ws.send(JSON.stringify({ kind:'queue' }));
      resolve();
    }, { once:true });

    ws.addEventListener('close', ()=>{
      appendLog('[PvP] Disconnected.');
      PVP.enabled = false;
      PVP.phase = 'idle';
      mountRightPanel();
      _wsOpenPromise = null;
    });

    ws.addEventListener('error', (e)=>{
      appendLog('[PvP] Connection error.');
      console.error(e);
    });

    ws.addEventListener('message', (ev)=>{
      try {
        const msg = JSON.parse(ev.data);
        handleNet(msg);
      } catch (err) {
        console.warn('Bad WS message:', ev.data, err);
      }
    });

  }); 

  return _wsOpenPromise;
}


// Assign stable netIds so both clients always sort/target the same units
function assignNetIds(hostUnits, guestUnits){
  if (!Array.isArray(hostUnits) || !Array.isArray(guestUnits)) return;

  hostUnits.forEach((u,i)=> { if (u) u.netId = `H${i}`; });
  guestUnits.forEach((u,i)=> { if (u) u.netId = `G${i}`; });
}

/* ---------- Battle bootstrap after draft (force-rebuild HUD) ---------- */

function assignNetIds(){
  // Host always gets H0/H1/H2; Guest always gets G0/G1/G2
  const hostUnits  = (PVP.role === 'host') ? player : enemy;
  const guestUnits = (PVP.role === 'host') ? enemy  : player;

  hostUnits.forEach((u,i)  => u.netId = `H${i}`);
  guestUnits.forEach((u,i) => u.netId = `G${i}`);
}

function resetAbilityUsesForBattle(units){
  for (const u of (units || [])) {
    if (!u) continue;
    // new system
    u._abilityUses = {};
    // clear legacy flags/counters (safe)
    delete u._godTempestUsed;
    delete u._shinobiPotionUses;
    delete u._rezUsed;
  }
}
window.resetAbilityUsesForBattle = resetAbilityUsesForBattle;

function startBattleFromDraft(){
  ensureRoundBuf();

  // close any overlays that could cover the scene
  const ov = document.getElementById('draft-overlay'); 
  if (ov) ov.remove();
  if (typeof unmountLobbyInField === 'function') unmountLobbyInField();


  // build units from picks (before restart)
  player = (Array.isArray(PVP.picksMe) ? PVP.picksMe : []).map(job => makeUnit(job, 'player'));
  enemy  = (Array.isArray(PVP.picksOpp) ? PVP.picksOpp : []).map(job => makeUnit(job, 'enemy'));
  ensureUnitSides();  // label units as host/guest before scene restart
window.resetAbilityUsesForBattle?.(player);
window.resetAbilityUsesForBattle?.(enemy);
assignNetIds(); // assigns netId based on current role

  PVP.phase = 'battle';
  PVP._readyForBattle = true; // flag for Scene.create to know we're in battle state

  // restart/boot scene and force a redraw pass shortly after
  if (game && sceneRef) {
    sceneRef.scene.restart();
    setTimeout(() => {
      if (sceneRef && typeof sceneRef.rebuildPanels === 'function') {
        sceneRef.rebuildPanels();
      }
    }, 50);
  } else if (game) {
    game.scene.start('Game');
  } else {
    bootPhaser();
  }

  mountRightPanel && mountRightPanel();
  appendLog('[PvP] Draft complete. Battle begins!');
}

// ============ ROUND SYNC (DROP-IN) ============
(function(){

  // Convert my local choice to the wire shape
  function choiceToWire(c){
  const abTarget = c.ability?.target;

  // Target can be:
  // - a live unit object (preferred locally)
  // - a wire object { targetName }
  const tn =
    (abTarget === 'self') ? null :
    (!c.target) ? null :
    (typeof c.target.alive === 'function')
      ? (typeof canonicalKey === 'function' ? canonicalKey(c.target) : (c.target.name || null))
      : (c.target.targetName ?? c.target.name ?? c.target.netId ?? null);

  return {
    actorName:    c.actor?.name || '',
    abilityLabel: c.ability?.label || 'Attack',
    targetName:   tn
  };
}
window.choiceToWire = choiceToWire;

  // Convert opponent wires back to local enemy-side choices
  function wireToChoiceEnemy(w){
    const actor = enemy.find(u=>u.name===w.actorName) || enemy[0];
    if (!actor) return null;
    const abList  = abilitiesFor(actor);
    const ability = abList.find(a=>a.label===w.abilityLabel) || abList[0];
    // Keep target in wire form; resolveSimultaneous() will rehydrate using allies/foes for THIS actor
let target = null;

if (w.targetName) {
  target = { targetName: w.targetName };
} else if (ability.target === 'self') {
  target = actor;
} else {
  target = null;
}

return { actor, ability, target };
  }
  window.wireToChoiceEnemy = wireToChoiceEnemy;

  function buildEnemyChoicesFromRemote(r){
    ensureRoundBuf();
    const theirWire = PVP.roundBuf.opp[r] || [];
    enemyChoices = theirWire.map(wireToChoiceEnemy).filter(Boolean);
    return enemyChoices;
  }
  window.buildEnemyChoicesFromRemote = buildEnemyChoicesFromRemote;

  function shallowEqualJSON(a,b){ try{ return JSON.stringify(a)===JSON.stringify(b); }catch{ return false; } }

  // Called by confirmChoice() after you've locked in everyone
  function sendMyRoundChoices(){
    ensureRoundBuf();
    const r    = roundNumber;
    const wire = (playerChoices || []).map(choiceToWire);

    PVP.roundBuf.mine[r] = wire;
    PVP.sentForRound     = r;
    if (PVP.role === 'host') PVP.roundBuf.host[r]  = wire;
    else                     PVP.roundBuf.guest[r] = wire;

    PVP.waitingForOpp = true;
    if (topLeftEl) topLeftEl.textContent = `Round ${r} ‚Äî Waiting for opponent‚Ä¶`;
    if (typeof clearActionBar === 'function') clearActionBar();

    // Send with both "kind" and "type" for compatibility
    send({
      kind: 'round_choices',
      type: 'round_choices',
      matchId: PVP.matchId,
      roomId:  PVP.roomId,
      round:   r,
      who:     PVP.role,          // 'host' | 'guest'
      choices: wire
    });
  }
  window.sendMyRoundChoices = sendMyRoundChoices;

  // Resolve once both sides for round r are present
  async function tryResolveRoundWithBothSides(r = roundNumber){
    if (PVP.phase !== 'battle') return;
    ensureRoundBuf();
    if (PVP._resolvingRound === r) return;
    PVP._resolvingRound = r;

    // rebuild my queue deterministically
    playerChoices = (PVP.roundBuf.mine[r] || []).map(w => {
      const actor   = player.find(u=>u.name===w.actorName) || pickDeterministic(player);
      const abList  = abilitiesFor(actor);
      const ability = abList.find(a=>a.label===w.abilityLabel) || abList[0];

      // Keep target in wire form; resolveSimultaneous() will rehydrate deterministically
let target = null;

if (w.targetName) {
  target = { targetName: w.targetName };
} else if (ability.target === 'self') {
  target = actor;
} else {
  target = null;
}

return { actor, ability, target };
    });

    // enemy from remote wires
    buildEnemyChoicesFromRemote(r);

    // seed RNG from both sides‚Äô wires so both clients match
    const hostWire  = PVP.roundBuf.host[r]  || (PVP.role==='host' ? PVP.roundBuf.mine[r] : PVP.roundBuf.opp[r]) || [];
    const guestWire = PVP.roundBuf.guest[r] || (PVP.role==='guest'? PVP.roundBuf.mine[r] : PVP.roundBuf.opp[r]) || [];
    const canon     = canonicalizeChoices(hostWire, guestWire);
    const roundSeed = (fnv1a(String(PVP.matchId||PVP.roomId||'0')) ^ fnv1a(String(r)) ^ fnv1a(canon)) >>> 0;
    seedRNG(roundSeed);
    appendLogHTML(`<span style="color:#ffd37a">‚Äî Round ${r} ‚Äî</span> <span style="opacity:.7">(seed ${roundSeed})</span>`);
    appendLogHTML(`<span style="opacity:.7">state# pre=${roundStateChecksum()}</span>`);
    const outcome = await resolveSimultaneous();
    appendLogHTML(`<span style="opacity:.7">state# post=${roundStateChecksum()}</span>`);
    PVP.waitingForOpp = false;

    if (outcome !== 'continue'){
      if (topLeftEl) topLeftEl.textContent = (outcome==='win')?'Victory!':'Defeat.';
      if (typeof clearActionBar === 'function') clearActionBar();
      if (typeof showEndOverlay === 'function') showEndOverlay(outcome==='win'?'win':'lose');

      send({
        kind: 'outcome',
        type: 'outcome',
        matchId: PVP.matchId,
        roomId:  PVP.roomId,
        round:   r,
        outcome
      });
      PVP._resolvingRound = null;
      return;
    }

    // advance to next round
    roundNumber++;
    delete PVP.roundBuf.mine[r];
    delete PVP.roundBuf.opp[r];
    PVP.sentForRound = null;

    resetRoundState();
    updateTopBarForCurrentSelection();
    renderActionBarForCurrent();
    if (typeof mountRightPanel === 'function') mountRightPanel();

    PVP._resolvingRound = null;
  }
  window.tryResolveRoundWithBothSides = tryResolveRoundWithBothSides;
})();

// ===== END OVERLAY (DROP-IN) =====
window.showEndOverlay = function(outcome){ // 'win' | 'lose' | 'draw'
  let ov = document.getElementById('result-overlay'); if (ov) ov.remove();
  ov = document.createElement('div'); ov.id='result-overlay';
  Object.assign(ov.style,{
    position:'fixed', inset:'0', background:'rgba(10,12,16,0.92)',
    zIndex:9999, display:'flex', alignItems:'center', justifyContent:'center', padding:'16px'
  });

  const card = document.createElement('div');
  Object.assign(card.style,{
    width:'min(720px,92vw)', background:'#1b2130', border:'2px solid #3a4257', borderRadius:'8px',
    boxShadow:'0 10px 40px rgba(0,0,0,.5)', padding:'24px', display:'flex',
    flexDirection:'column', gap:'18px', alignItems:'center'
  });

  const title = document.createElement('div');
  title.style.cssText = 'font-size:36px;font-weight:900;';
  title.textContent = (outcome==='win') ? 'üèÜ Victory!' : (outcome==='lose' ? 'üíÄ Defeat' : '‚è∏ Draw');
  card.appendChild(title);

  const row = document.createElement('div');
  row.style.cssText = 'display:flex;gap:10px;flex-wrap:wrap;justify-content:center;';

  function mk(label, onClick){
    const b = document.createElement('button');
    b.className = 'action-btn'; b.style.padding = '12px 16px';
    b.innerHTML = `<div class="label" style="font-size:18px">${label}</div>`;
    b.onclick = onClick; return b;
  }

const toLobby = () => {
  ov.remove();

  // Always reset UI/state locally first
  returnToLobby();

  // If connected, refresh rooms; if not, connect then refresh
  if (PVP.ws && PVP.ws.readyState === WebSocket.OPEN) {
    send({ kind:'list_rooms' });
  } else {
    connectWS().then(() => send({ kind:'list_rooms' }));
  }
};

const playAgain = () => {
  ov.remove();

  // Reset everything to lobby state first
  returnToLobby();

  // Then immediately queue
  connectWS().then(() => send({ kind:'queue' }));
};

  row.appendChild(mk('Return to Lobby', toLobby));
  card.appendChild(row);
  ov.appendChild(card);
  document.body.appendChild(ov);
};

function portraitURL(job){
  const base = (window.SPRITE_BASE_URL || 'https://raw.githubusercontent.com/krezt/tol-assets/main')
    .replace(/\/+$/,'');
  return `${base}/portraits/${encodeURIComponent(job)}.png`;
}

/* ---------- Net handler ---------- */
function handleNet(msg){
  switch(msg.kind){

    case 'hello_ack': {
      PVP.meId = msg.id;
      break;
    }

    case 'queued': {
      appendLog('[PvP] Searching for opponent‚Ä¶');
      PVP.enabled = true; PVP.phase = 'idle';
      break;
    }

    case 'opponent_disconnected': {
      appendLog('[PvP] Opponent disconnected.');
      PVP._ended = false;
      PVP.matchId = PVP.roomId = null;
      PVP.role = null; PVP.phase = 'idle';
      player = []; enemy = [];
      if (game && sceneRef) sceneRef.scene.restart();
      mountLobbyInField();
      break;
    }

    // Lobby replies
    case 'rooms': {
      refreshLobbyList(Array.isArray(msg.rooms) ? msg.rooms : []);
      break;
    }
    case 'room_created': {
      setLobbyRoomStatus(msg.id);
      send({ kind:'list_rooms' }); // refresh
      break;
    }
    case 'room_joined': {
      appendLog('[PvP] Joined room. Waiting for opponent‚Ä¶');
      break;
    }
    case 'error': {
      appendLog('[PvP] ' + (msg.msg || 'Error.'));
      showLobbyError(msg.msg || 'Server error.');
      break;
    }
case 'round_choices': {
  ensureRoundBuf();
if (!PVP.roundBuf.host || !PVP.roundBuf.guest) {
  console.warn('[DBG] roundBuf missing host/guest keys', PVP.roundBuf);
}
  const r  = (typeof msg.round==='number') ? msg.round : roundNumber;
  const ch = Array.isArray(msg.choices) ? msg.choices : [];

  let bucket;
  if (msg.who==='host' || msg.who==='guest'){
    bucket = (msg.who === PVP.role) ? 'mine' : 'opp';
    PVP.roundBuf[msg.who][r] = ch;    // keep per-side copy for seeding
  } else {
    // fallback: decide by actor names present
    const names   = ch.map(c=>c.actorName);
    const myNames = (player||[]).map(u=>u.name);
    const allIn   = names.length && names.every(n=>myNames.includes(n));
    bucket = allIn ? 'mine' : 'opp';
  }
  PVP.roundBuf[bucket][r] = ch;

  if (PVP.phase==='battle' && r===roundNumber &&
      Array.isArray(PVP.roundBuf.mine[r]) && Array.isArray(PVP.roundBuf.opp[r])){
    tryResolveRoundWithBothSides(r);
  }
  break;
}


    // Names (various shapes)
    case 'opponent_name':
    case 'peer_name':
    case 'name_update':
    case 'name': {
      const theirRole = msg.who || msg.role || msg.from || null;
      const name      = msg.name || msg.opponentName || msg.playerName || '';
      const isFromMe  = (theirRole && theirRole === PVP.role);
      if (name && !isFromMe){
        PVP.opponentName = name;
        if (sceneRef && sceneRef.updateHeaderNames) sceneRef.updateHeaderNames();
        const oppTitle = document.getElementById('oppTitle');
        if (oppTitle) oppTitle.textContent = PVP.opponentName || 'Opponent';
      }
      break;
    }

    // Match start (rooms flow)
    case 'match': {
  PVP.roomId  = msg.roomId || PVP.roomId;
  PVP.role    = (msg.you === 'A') ? 'host' : 'guest';
  PVP.matchId = PVP.roomId;

  PVP.phase = 'draft';
PVP.pool = [...ALL_CLASSES];
PVP.picksMe = [];
PVP.picksOpp = [];
PVP.pickCount = 0;

// A‚ÄìB‚ÄìB‚ÄìA‚ÄìB‚ÄìA: host goes first
const sideTurn = DRAFT_ORDER[PVP.pickCount]; // 'host'
PVP.pickTurn = (sideTurn === PVP.role) ? 'me' : 'opp';

  unmountLobbyInField && unmountLobbyInField();
  mountDraftUI();
  updateDraftUI();
  appendLog('[PvP] Match ready. Draft begins.');
  break;
}

    // Draft pick
    case 'draft_pick': {
      const by = msg.by, job = msg.job;
      PVP.pool = PVP.pool.filter(j => j !== job);
      if ((by === PVP.role) || (by === 'host' && PVP.role === 'host') || (by === 'guest' && PVP.role === 'guest')){
        PVP.picksMe.push(job);
      } else {
        PVP.picksOpp.push(job);
      }
      PVP.pickCount++;

// Next turn based on A‚ÄìB‚ÄìB‚ÄìA‚ÄìB‚ÄìA sequence
const nextSide = DRAFT_ORDER[PVP.pickCount] || null; // pickCount was incremented already
PVP.pickTurn = nextSide ? ((nextSide === PVP.role) ? 'me' : 'opp') : null;

      updateDraftUI();

const totalPicks = PVP.picksMe.length + PVP.picksOpp.length;
if (totalPicks >= 6) {
  startBattleFromDraft();
}
break;
    }



    // Final outcome (flip perspective if needed)
    case 'outcome': {
      if (PVP._ended) break;
      let out = msg.outcome;
      if (msg.from && msg.from !== PVP.role){
        out = (out === 'win') ? 'lose' : (out === 'lose' ? 'win' : out);
      }
      PVP._ended = true;
      if (topLeftEl) topLeftEl.textContent = (out === 'win') ? 'Victory!' : 'Defeat.';
      clearActionBar();
      showEndOverlay(out === 'win' ? 'win' : 'lose');
      break;
    }

    default: break;
  }
}

/* ---------- Right panel (names + find match) ---------- */
function showRightWaitHint(){
  const box = document.getElementById('action-bar-right');
  if (!box) return;
  box.textContent = '';
  const hint = document.createElement('div');
  hint.style.cssText = 'font-size:12px;opacity:.85;text-align:center;padding:8px;';
  hint.textContent = 'Waiting for opponent‚Ä¶';
  box.appendChild(hint);
}

function mountRightPanel(){
  setStaticRightPanelImage(window.ACTION_RIGHT_URL);
}

/* ---------- Draft UI ---------- */
function getOrCreateDraftOverlay(){
  let ov=document.getElementById('draft-overlay'); if (ov) return ov;
  ov=document.createElement('div'); ov.id='draft-overlay';
  Object.assign(ov.style,{position:'fixed',inset:'0',background:'rgba(10,12,16,0.92)',zIndex:'9999',display:'flex',alignItems:'center',justifyContent:'center',padding:'16px'});
  const card=document.createElement('div'); card.id='draft-card';
  Object.assign(card.style,{width:'min(1000px,92vw)',height:'min(720px,88vh)',background:'#1b2130',border:'2px solid #3a4257',borderRadius:'8px',display:'flex',flexDirection:'column',overflow:'hidden',boxShadow:'0 10px 40px rgba(0,0,0,.5)'});

  const header=document.createElement('div'); header.id='draft-header';
  Object.assign(header.style,{padding:'12px 16px',borderBottom:'1px solid #3a4257',display:'flex',alignItems:'center',justifyContent:'space-between',gap:'8px'});
  header.innerHTML=`<div style="font-weight:800;font-size:20px;">Draft: Pick 3 Heroes</div><div id="draft-sub" style="font-size:13px;opacity:.9;">You are <b>${PVP.role}</b>. Turn: <b id="turnChip"></b></div>`;

  const picksRow=document.createElement('div'); picksRow.id='draft-picks-row';
  Object.assign(picksRow.style,{padding:'12px 16px',display:'grid',gridTemplateColumns:'1fr 1fr',gap:'16px',borderBottom:'1px solid #3a4257'});
  picksRow.innerHTML=`<div><div style="font-weight:700;margin-bottom:6px;">Your Picks</div><div id="myPicks" style="min-height:24px;opacity:.95"></div></div>
                      <div><div id="oppTitle" style="font-weight:700;margin-bottom:6px;">${PVP.opponentName||'Opponent'}</div><div id="oppPicks" style="min-height:24px;opacity:.95"></div></div>`;

  const poolWrap=document.createElement('div'); poolWrap.id='draft-pool-wrap';
  Object.assign(poolWrap.style,{padding:'12px 16px',display:'flex',flexDirection:'column',gap:'8px',minHeight:0,flex:'1 1 auto'});
  const poolHeader=document.createElement('div'); poolHeader.innerHTML=`
    <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
      <div style="font-weight:700;">Available</div>
      <input id="draft-filter" placeholder="Filter classes‚Ä¶" style="background:#22314b;color:#fff;border:1px solid #4a5a7a;border-radius:4px;padding:6px 8px;min-width:180px;">
    </div>`;
  const pool=document.createElement('div'); pool.id='pool';
  Object.assign(pool.style,{display:'grid',gridTemplateColumns:'repeat(auto-fill, minmax(200px, 1fr))',gap:'8px',overflow:'auto',minHeight:0,flex:'1 1 auto',paddingBottom:'4px'});
  poolWrap.appendChild(poolHeader); poolWrap.appendChild(pool);

  const footer=document.createElement('div');
  Object.assign(footer.style,{padding:'10px 16px',borderTop:'1px solid #3a4257',display:'flex',alignItems:'center',justifyContent:'space-between',fontSize:'12px',opacity:'.85'});
  footer.innerHTML = `
  <div>Draft order: A‚ÄìB‚ÄìB‚ÄìA‚ÄìB‚ÄìA. Battle starts when each player has 3 picks.</div>
  <button id="draft-cancel" class="action-btn" style="padding:6px 10px;">Cancel</button>
`;

  card.appendChild(header); card.appendChild(picksRow); card.appendChild(poolWrap); card.appendChild(footer); ov.appendChild(card); document.body.appendChild(ov);
  document.getElementById('draft-cancel').onclick = () => {
  try {
    // 1) Remove the draft overlay immediately
    const ovNow = document.getElementById('draft-overlay');
    if (ovNow) ovNow.remove();

    // 2) Reset state + rebuild UI back to main lobby (your existing function)
    if (typeof returnToLobby === 'function') returnToLobby();
    else if (typeof showLobby === 'function') showLobby(); // fallback
  } catch (e) {
    console.error('draft cancel failed', e);
  }
};

  const filter=document.getElementById('draft-filter'); filter.addEventListener('input', ()=>updateDraftUI());
  return ov;
}

function mountDraftUI(){
  getOrCreateDraftOverlay();
  const box=document.getElementById('action-bar-right');
  if (box){ box.textContent=''; const hint=document.createElement('div'); hint.style.cssText='font-size:12px;opacity:.85;text-align:center;padding:8px;'; hint.textContent='Draft in progress‚Ä¶'; box.appendChild(hint); }
  updateDraftUI();
}

function updateDraftUI(){
  // --- turn chip (now driven by DRAFT_ORDER + pickCount) ---
  const turnChip = document.getElementById('turnChip');
  const pickIndex = (PVP.pickCount ?? 0);
  const sideToPick = DRAFT_ORDER[pickIndex] || null; // 'host' | 'guest' | null when done
  const mine = !!sideToPick && (sideToPick === PVP.role);

  if (turnChip){
    if (!sideToPick){
      turnChip.textContent = 'Draft complete';
      turnChip.style.color = '#a7c4ff';
    } else {
      const sideLabel = (sideToPick === 'host') ? 'A' : 'B';
      turnChip.textContent = mine ? `Your pick (Side ${sideLabel})` : `Opponent (Side ${sideLabel})`;
      turnChip.style.color = mine ? '#a7ffb5' : '#ffd37a';
    }
  }

  // --- picks + opponent name ---
  const myP = document.getElementById('myPicks');
  const opP = document.getElementById('oppPicks');
  if (myP) myP.textContent = (PVP.picksMe.join(', ') || '‚Äî');
  if (opP) opP.textContent = (PVP.picksOpp.join(', ') || '‚Äî');

  const oppTitle = document.getElementById('oppTitle');
  if (oppTitle) oppTitle.textContent = PVP.opponentName || 'Opponent';

  // --- pool + filter ---
  const pool = document.getElementById('pool');
  if (!pool) return;

  const filter = document.getElementById('draft-filter');
  const q = (filter?.value || '').trim().toLowerCase();

  pool.textContent = '';
  const remaining = (PVP.pool || []).filter(j => !q || j.toLowerCase().includes(q));

  // Can I pick right now?
  const canPick = mine && (PVP.picksMe.length < 3) && !!sideToPick;

  for (const job of remaining){
    const b = document.createElement('button');
    b.className = 'action-btn';

    // vertical card styling
    Object.assign(b.style, {
      padding:'10px',
      textAlign:'left',
      whiteSpace:'normal',
      lineHeight:'1.2',
      display:'flex',
      flexDirection:'column',
      gap:'6px',
      alignItems:'stretch'
    });

    // Title
    const title = document.createElement('div');
    title.className = 'label';
    title.textContent = job;
    Object.assign(title.style, { fontWeight:'800' });

    // One-liner
    const desc = document.createElement('div');
    desc.className = 'desc';
    desc.textContent = (window.CLASS_BLURBS && window.CLASS_BLURBS[job]) || '‚Äî';
    Object.assign(desc.style, { opacity:'0.9' });

    // Portrait (centered under text)
    const img = document.createElement('img');
    img.src = portraitURL(job);
    img.alt = job;
    Object.assign(img.style, {
      width:'100%',
      maxWidth:'100px',
      height:'auto',
      marginTop:'6px',
      borderRadius:'8px',
      objectFit:'cover',
      border:'1px solid rgba(255,255,255,0.15)',
      background:'rgba(0,0,0,0.2)',
      alignSelf:'center'
    });
    img.onerror = () => { img.style.display = 'none'; };

    b.appendChild(title);
    b.appendChild(desc);
    b.appendChild(img);

    // Enable/disable pick based on order + pick cap
    b.disabled = !canPick;

    b.onclick = () => {
      if (!canPick) return;
      b.disabled = true;
      send({ kind:'draft_pick', job, by: PVP.role }); // server should broadcast back 'draft_pick'
    };

    pool.appendChild(b);
  }
}

function showLobby(){
  try { if (typeof enterLobbyUI === 'function') enterLobbyUI(); } catch(e){ console.error('enterLobbyUI failed', e); }
  try { if (typeof mountLobbyInField === 'function') mountLobbyInField(); } catch(e){ console.error('mountLobbyInField failed', e); }
  try { if (typeof setTopBarLobby === 'function') setTopBarLobby(); } catch(e){ console.error('setTopBarLobby failed', e); }
}

function clearCombatUI(){
  // Clear combat log (adjust id if yours differs)
  const log = document.getElementById('combatLog') || document.getElementById('combat-log');
  if (log) log.innerHTML = '';

  // Clear / hide action bar (adjust id if yours differs)
  const bar = document.getElementById('actionBar') || document.getElementById('action-bar');
  if (bar) { bar.innerHTML = ''; bar.style.display = 'none'; }

  // Clear other battle-only UI (if you have it)
  const hud = document.getElementById('battleHUD') || document.getElementById('battle-hud');
  if (hud) hud.style.display = 'none';

  // Clear any pending targeting state you use
  window._pendingTargetPick = false;
  window._pendingAbility = null;
  window._pendingAbilityTarget = null;
}

function returnToLobby(){
  // Phase + match state
  PVP.phase = 'idle';
  PVP.matchId = null;
  PVP.roomId = null;
  PVP.role = null;
  PVP._readyForBattle = false;
PVP._ended = false;
PVP._resolvingRound = null;
PVP.sentForRound = null;
ensureRoundBuf();
PVP.roundBuf.mine = {};
PVP.roundBuf.opp  = {};
PVP.roundBuf.host = {};
PVP.roundBuf.guest= {};


  // Clear units so Phaser panels don‚Äôt keep drawing old match
  player = [];
  enemy  = [];

  // Clear right-side DOM UI
  clearCombatUI();

  // Rebuild Phaser panels empty (if scene is alive)
  if (sceneRef && typeof sceneRef.rebuildPanels === 'function') {
    sceneRef.rebuildPanels();
  }

  // Show lobby overlay + lobby top bar
  mountLobbyInField();
  setTopBarLobby();
}


/* ===== Lobby overlay in battlefield (DOM, not Phaser) ===== */
function unmountLobbyInField(){
  const ov = document.getElementById('lobby-overlay');
  if (ov) ov.remove();
}

function mountLobbyInField(){
  unmountLobbyInField();
  const root = document.getElementById('battlefield');
  if (!root) return;
  root.style.position = 'relative';

  const ov = document.createElement('div');
  ov.id = 'lobby-overlay';
  Object.assign(ov.style, {
    position:'absolute', inset:'8px',
    background:'rgba(10,12,16,0.92)', border:'2px solid #3a4257', borderRadius:'8px',
    color:'#e8e8f0', zIndex: 5, display:'flex', flexDirection:'column', gap:'10px', padding:'12px'
  });

  // Header + name
  const header = el('div', { style:{ display:'flex', alignItems:'center', justifyContent:'space-between', gap:'8px' }});
  header.appendChild(el('div', { style:{ fontWeight:'800', fontSize:'20px' }}, 'PvP Lobby'));
  const nameWrap = el('div', { style:{ display:'flex', gap:'6px', alignItems:'center' }});
  nameWrap.appendChild(el('label', { style:{ fontSize:'12px', opacity:.9 }}, 'Your name:'));
  const nameInput = el('input', { id:'lobby-name', placeholder:'Type your name', value:(PVP.myName||PVP.playerName||'') });
  Object.assign(nameInput.style, { background:'#22314b', color:'#fff', border:'1px solid #4a5a7a', borderRadius:'4px', padding:'6px 8px', minWidth:'160px' });
  const saveBtn = el('button', { class:'action-btn', style:{ padding:'6px 10px' }}, el('div', { class:'label', style:{ fontSize:'14px' }}, 'Save'));
  header.appendChild(nameWrap);
  nameWrap.appendChild(nameInput); nameWrap.appendChild(saveBtn);
  ov.appendChild(header);

  // Tip + error
  const tip  = el('div', { id:'lobby-tip',  style:{ fontSize:'12px', opacity:.85, textAlign:'center' }}, 'Tip: share the room ID so friends can join.');
  const err  = el('div', { id:'lobby-error',style:{ fontSize:'12px', color:'#ffb3b3', textAlign:'center', display:'none' }}, '');
  ov.appendChild(tip); ov.appendChild(err);

  // Controls: Create room, Quick Match, Join by ID
  const controls = el('div', { style:{ display:'flex', gap:'8px', flexWrap:'wrap', justifyContent:'center' }});
  const mkBtn = (label, onClick) => {
    const b = el('button', { class:'action-btn', style:{ padding:'8px 12px' }}, el('div', { class:'label', style:{ fontSize:'16px' }}, label));
    b.onclick = onClick; return b;
  };
  const createBtn = mkBtn('Create Room', async ()=>{ await connectWS(); send({ kind:'create_room' }); });
  const quickBtn  = mkBtn('Quick Match', async ()=>{ await connectWS(); send({ kind:'queue' }); });
  controls.appendChild(createBtn); controls.appendChild(quickBtn);

  // Join by ID
  const joinWrap = el('div', { style:{ display:'flex', gap:'6px', alignItems:'center', justifyContent:'center' }});
  const joinInp  = el('input', { id:'lobby-join-id', placeholder:'Enter room ID' });
  Object.assign(joinInp.style, { background:'#22314b', color:'#fff', border:'1px solid #4a5a7a', borderRadius:'4px', padding:'6px 8px', minWidth:'140px' });
  const joinBtn  = mkBtn('Join', async ()=>{ const id=(joinInp.value||'').trim(); if(!id) return; await connectWS(); send({ kind:'join_room', id }); });
  joinWrap.appendChild(joinInp); joinWrap.appendChild(joinBtn);

  ov.appendChild(controls);
  ov.appendChild(joinWrap);

  // Status after create
  const roomStatus = el('div', { id:'lobby-room-status', style:{ display:'none', textAlign:'center', fontSize:'13px' }});
  ov.appendChild(roomStatus);

  // List
  const list = el('div', { id:'lobby-rooms', style:{ marginTop:'6px', overflow:'auto', flex:'1 1 auto', borderTop:'1px solid #3a4257', paddingTop:'8px' }});
  ov.appendChild(list);

  root.appendChild(ov);

// keep lobby UI consistent
enterLobbyUI();
setTopBarLobby();

  // Save name handlers
  const saveName = () => {
    const v = (nameInput.value || '').trim().slice(0,16);
    if (!v) return;
    PVP.myName = v; PVP.playerName = v;
    connectWS().then(()=> send({ kind:'set_name', name:v }));
    if (sceneRef && sceneRef.updateHeaderNames) sceneRef.updateHeaderNames();
  };
  saveBtn.onclick = saveName;
  nameInput.addEventListener('keydown', e => { if (e.key==='Enter') { e.preventDefault(); saveName(); }});
  nameInput.addEventListener('blur', saveName);

  // Ask for rooms + periodic refresh
  connectWS().then(()=>{
    send({ kind:'list_rooms' });
    const errTimer = setTimeout(()=>{
      const e = document.getElementById('lobby-error');
      const ls= document.getElementById('lobby-rooms');
      if (e && ls && !ls.dataset.populated){
        e.textContent = 'No response from server. Lobby features may not be enabled on this server.';
        e.style.display = 'block';
      }
    }, 2000);
    PVP._roomsInterval && clearInterval(PVP._roomsInterval);
    PVP._roomsInterval = setInterval(()=> send({ kind:'list_rooms' }), 2500);
  });
}

function refreshLobbyList(rooms){
  const list = document.getElementById('lobby-rooms');
  const err  = document.getElementById('lobby-error');
  if (!list) return;
  list.textContent = '';
  list.dataset.populated = '1';
  if (err) err.style.display = 'none';

  if (!rooms || rooms.length === 0){
    const empty = el('div', { style:{ opacity:.8, fontSize:'13px', textAlign:'center', padding:'8px' }}, 'No rooms yet. Create one!');
    list.appendChild(empty);
    return;
  }
  for (const r of rooms){
    // server returns {id, name, players}
    const row  = el('div', { style:{ display:'flex', alignItems:'center', justifyContent:'space-between', border:'1px solid #3a4257', background:'#1b2130', borderRadius:'6px', padding:'8px', marginBottom:'6px' }});
    const info = el('div', {}, `${r.id} ‚Äî ${r.name || 'Room'} (${r.players || 1}/2)`);
    const jBtn = el('button', { class:'action-btn', style:{ padding:'6px 10px' }}, el('div', { class:'label', style:{ fontSize:'14px' }}, 'Join'));
    jBtn.onclick = async ()=>{ await connectWS(); send({ kind:'join_room', id: r.id }); };
    row.appendChild(info); row.appendChild(jBtn);
    list.appendChild(row);
  }
}

function showLobbyError(msg){
  const e = document.getElementById('lobby-error');
  if (e){ e.textContent = msg; e.style.display = 'block'; }
}

function setLobbyRoomStatus(id){
  const n = document.getElementById('lobby-room-status');
  if (!n) return;
  if (id){
    n.style.display = 'block';
    n.textContent = `Room ${id} created. Waiting for opponent‚Ä¶  (Share this ID to invite friends)`;
  } else {
    n.style.display = 'none';
    n.textContent = '';
  }
}


/* ---------- Boot right panel on load ---------- */
window.addEventListener('load', ()=>{ if (PVP.phase!=='draft') mountRightPanel(); });

</script>
</body>
</html>



