{label:'Death Touch', desc:'Crush a third of your target\'s HP.', speed:'slow', type:'mag', target:'enemy',
  use:(a,t)=>{
    if (!t?.alive?.()) return appendLog(`${t?.name || 'Target'} is already down.`);

    const third = Math.floor(t.hp / 3); // ✅ compute first

    vfxActCue?.(a, 'Death Touch');
    vfxSiphonRings(a, t, { ms: vfxMs?.(360) ?? 360, color: 0xff6b6b, rings: 3 });

    const scene = getScene?.();
    const delayMs = (vfxMs?.(360) ?? 360);
    const delay = Math.max(0, Math.floor(delayMs * 0.90));

    const doImpact = () => {
      // ✅ don't depend on vfxDeathTouch existing
      if (typeof vfxDeathTouch === 'function') vfxDeathTouch(t, { color: 0xff6b6b });
      else {
        vfxFlashColor?.(t, { color: 0xff6b6b, ms: vfxMs?.(260) ?? 260, alpha: 0.22 });
        vfxShakePanel?.(t, { px: (VFX?.SHAKE_PX ?? 6), ms: vfxMs?.(220) ?? 220 });
      }

      vfxFloatText?.(t, `-${third}`, { ms: vfxMs?.(1400) ?? 1400, fontSize: 22, color:'#ff6b6b' });
    };

    if (scene?.time?.delayedCall) scene.time.delayedCall(delay, doImpact);
    else doImpact();

    // apply HP change after scheduling (fine)
    t.hp = clamp(t.hp - third, 0, t.maxHP);
    t._refresh?.();
    checkHPWarnings?.(t);

    appendLogHTML?.(`<span style="color:#ff6b6b">${a.name} invokes Death Touch! ${t.name} loses ${third} HP.</span>`)
      || appendLog(`${a.name} invokes Death Touch! ${t.name} loses ${third} HP.`);
  }
},
